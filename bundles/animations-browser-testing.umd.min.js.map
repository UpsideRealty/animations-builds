{"version":3,"file":"animations-browser-testing.umd.min.js","sources":["../../../../packages/animations/browser/src/render/shared.ts","../../../../packages/animations/browser/testing/src/mock_animation_driver.ts","../../../../packages/animations/browser/testing/src/testing.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData = {},\n    postStyles: ɵStyleData = {}): ɵStyleData[] {\n  const errors: string[] = [];\n  const normalizedKeyframes: ɵStyleData[] = [];\n  let previousOffset = -1;\n  let previousKeyframe: ɵStyleData|null = null;\n  keyframes.forEach(kf => {\n    const offset = kf['offset'] as number;\n    const isSameOffset = offset == previousOffset;\n    const normalizedKeyframe: ɵStyleData = (isSameOffset && previousKeyframe) || {};\n    Object.keys(kf).forEach(prop => {\n      let normalizedProp = prop;\n      let normalizedValue = kf[prop];\n      if (normalizedValue == PRE_STYLE) {\n        normalizedValue = preStyles[prop];\n      } else if (normalizedValue == AUTO_STYLE) {\n        normalizedValue = postStyles[prop];\n      } else if (prop != 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(prop, errors);\n        normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, kf[prop], errors);\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player.totalTime)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player.totalTime)));\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)));\n      break;\n  }\n}\n\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  return makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n}\n\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n\nexport function parseTimelineCommand(command: string): [string, string] {\n  const separatorPos = command.indexOf(':');\n  const id = command.substring(1, separatorPos);\n  const action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n\nlet _query: (element: any, selector: string, multi: boolean) => any[] =\n    (element: any, selector: string, multi: boolean) => {\n      return [];\n    };\nif (typeof Element == 'function') {\n  _query = (element: any, selector: string, multi: boolean): any[] => {\n    let results: any[] = [];\n    if (multi) {\n      results.push(...element.querySelectorAll(selector));\n    } else {\n      const elm = element.querySelector(selector);\n      if (elm) {\n        results.push(elm);\n      }\n    }\n    return results;\n  };\n}\nexport const invokeQuery = _query;\n\nlet _contains: (elm1: any, elm2: any) => boolean = (elm1: any, elm2: any) => false;\nif (typeof Element == 'function') {\n  _contains = (elm1: any, elm2: any) => { return elm1.contains(elm2) as boolean; };\n}\nexport const containsElement = _contains;\n\nlet _matches: (element: any, selector: string) => boolean = (element: any, selector: string) =>\n    false;\nif (typeof Element == 'function') {\n  if (Element.prototype.matches) {\n    _matches = (element: any, selector: string) => element.matches(selector);\n  } else {\n    const proto = Element.prototype as any;\n    const fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n        proto.oMatchesSelector || proto.webkitMatchesSelector;\n    if (fn) {\n      _matches = (element: any, selector: string) => fn.apply(element, [selector]);\n    }\n  }\n}\n\nexport const matchesElement = _matches;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../../src/render/animation_driver';\nimport {containsElement, invokeQuery, matchesElement} from '../../src/render/shared';\n\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationDriver implements AnimationDriver {\n  static log: AnimationPlayer[] = [];\n\n  matchesElement(element: any, selector: string): boolean {\n    return matchesElement(element, selector);\n  }\n\n  containsElement(elm1: any, elm2: any): boolean { return containsElement(elm1, elm2); }\n\n  query(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): MockAnimationPlayer {\n    const player =\n        new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\n    MockAnimationDriver.log.push(<AnimationPlayer>player);\n    return player;\n  }\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationPlayer extends NoopAnimationPlayer {\n  private __finished = false;\n  private __started = false;\n  public previousStyles: {[key: string]: string | number} = {};\n  private _onInitFns: (() => any)[] = [];\n  public currentSnapshot: ɵStyleData = {};\n\n  constructor(\n      public element: any, public keyframes: {[key: string]: string | number}[],\n      public duration: number, public delay: number, public easing: string,\n      public previousPlayers: any[]) {\n    super();\n    previousPlayers.forEach(player => {\n      if (player instanceof MockAnimationPlayer) {\n        const styles = player.currentSnapshot;\n        Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n      }\n    });\n\n    this.totalTime = delay + duration;\n  }\n\n  /* @internal */\n  onInit(fn: () => any) { this._onInitFns.push(fn); }\n\n  /* @internal */\n  init() {\n    super.init();\n    this._onInitFns.forEach(fn => fn());\n    this._onInitFns = [];\n  }\n\n  finish(): void {\n    super.finish();\n    this.__finished = true;\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.__finished = true;\n  }\n\n  /* @internal */\n  triggerMicrotask() {}\n\n  play(): void {\n    super.play();\n    this.__started = true;\n  }\n\n  hasStarted() { return this.__started; }\n\n  beforeDestroy() {\n    const captures: ɵStyleData = {};\n\n    Object.keys(this.previousStyles).forEach(prop => {\n      captures[prop] = this.previousStyles[prop];\n    });\n\n    if (this.hasStarted()) {\n      // when assembling the captured styles, it's important that\n      // we build the keyframe styles in the following order:\n      // {other styles within keyframes, ... previousStyles }\n      this.keyframes.forEach(kf => {\n        Object.keys(kf).forEach(prop => {\n          if (prop != 'offset') {\n            captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\n          }\n        });\n      });\n    }\n\n    this.currentSnapshot = captures;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {MockAnimationDriver, MockAnimationPlayer} from './mock_animation_driver';\n"],"names":["_query","element","selector","multi","Element","results","push","apply","querySelectorAll","elm","querySelector","invokeQuery","_contains","elm1","elm2","contains","containsElement","_matches","prototype","matches","proto","MockAnimationDriver","matchesElement","query","computeStyle","prop","defaultValue","previousPlayers","player","MockAnimationPlayer","keyframes","duration","delay","easing","log","_super","_this","call","this","__finished","__started","previousStyles","currentSnapshot","Object","keys","styles_1","forEach","__extends","onInit","fn","_onInitFns","init","finish","destroy","triggerMicrotask","play","beforeDestroy","hasStarted","kf"],"mappings":";;;;;wrBA+HAA,OAAA,SAAAC,QAAAC,SAAAC,OACA,SAEA,mBAAAC,WACAJ,OAAA,SAAAC,QAAAC,SAAAC,OACA,GAAAE,WACA,IAAAF,MACAE,QAAAC,KAAAC,MAAAF,QAAAJ,QAAAO,iBAAAN,eAGA,CACA,GAAAO,KAAsBR,QAAtBS,cAAAR,SACAO,MACAJ,QAAAC,KAAAG,KAKA,MAAAJ,UAGA,IAAAM,aAAAX,OAAAY,UAAA,SAAAC,KAAAC,MAAA,OAAA,EACkB,mBAAlBV,WACAQ,UAAY,SAAZC,KAAAC,MAAA,MAAAD,MAAAE,SAAAD,OAEA,IAAAE,iBAAAJ,UACAK,SAAA,SAAAhB,QAAAC,UAAA,OAAA,EACA,IAAA,kBAAAE,SACA,GAAAA,QAAAc,UAAAC,QACAF,SAAA,SAAAhB,QAAAC,UAAA,MAAAD,SAAAkB,QAAAjB,gBC5JA,GAAAkB,OAAAhB,QAAAc,4PA6BAG,oBAAA,WACA,QAAAA,8BAGAA,qBAAAH,UAAAI,eAAA,SAAArB,QAAAC,UAGA,MAAAoB,gBAAArB,QAAAC,WAGAmB,oBAAAH,UAAAF,gBAAA,SAAAH,KAAAC,MAAA,MAAAE,iBAAAH,KAAAC,OACAO,oBAAAH,UAAAK,MAAA,SAAAtB,QAAAC,SAAAC,mDAvBAkB,oBAAAH,UAAAM,aAAA,SAAAvB,QAAAwB,KAAAC,+IA6BA,SAAAC,kBAAAA,mBAAA,IAAAC,QAAA,GAAAC,qBAAA5B,QAAA6B,UAAAC,SAAAC,MAAAC,OAAAN,uBAOAN,qBAAAa,IAAA5B,KAAAsB,sCAEAP,qBAAAa,MARA,IAAAL,qBAAA,SAAAM,QAEA,QAAAN,qBAAA5B,QAAA6B,UAAAC,SAAAC,MAAAC,OAAAN,iBACU,GAAVS,OAAAD,OAAAE,KAAAC,OAAAA,IA4BA,OA3BSF,OAATnC,QAAAA,QAOImC,MAAJN,UAAAA,UACAM,MAAAL,SAAAA,SACAK,MAAAJ,MAAAA,MACAI,MAAAH,OAAAA,OACAG,MAAOT,gBAAPA,gBACAS,MAAAG,YAAA,EAEAH,MAAAI,WAAA,EACAJ,MAAAK,sCAGAL,MAAAM,4DAGA,GAAAd,iBAAAC,qBAAA,oCACAc,QAAAC,KAAAC,UAAAC,QAAA,SAAArB,MAAA,MAAAW,OAAAK,eAAAhB,MAAAoB,SAAApB,0CAKAW,YA9BAW,WAAAlB,oBAAAM,QAiCAN,oBAAAX,UAAA8B,OAAA,SAAAC,IAAAX,KAAAY,WAAA5C,KAAA2C,KAGApB,oBAAAX,UAAAiC,KAAA,WACIhB,OAAJjB,UAAAiC,KAAAd,KAAAC,MACAA,KAAAY,WAAAJ,QAAA,SAAAG,IAAA,MAAAA,4BAKApB,oBAAAX,UAAAkC,OAAA,WACIjB,OAAJjB,UAAAkC,OAAAf,KAAAC,MACAA,KAAAC,YAAA,GAGEV,oBAAFX,UAAAmC,QAAA,WAEAlB,OAAAjB,UAAAmC,QAAAhB,KAAAC,MACIA,KAAJC,YAAA,GAIAV,oBAAAX,UAAAoC,iBAAA,aAEAzB,oBAAAX,UAAAqC,KAAA,WAAApB,OAAAjB,UAAAqC,KAAAlB,KAAAC,oGAIAT,oBAAAX,UAAAsC,cAAA,WACA,GAAApB,OAAAE,qHAKAA,KAAAmB,cAKAnB,KAAAR,UAAAgB,QAAA,SAAAY,2CCxHA,UAAAjC"}