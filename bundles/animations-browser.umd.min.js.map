{"version":3,"file":"animations-browser.umd.min.js","sources":["../../../../packages/animations/browser/src/render/dom_animation_engine_next.ts","../../../../packages/animations/browser/src/render/noop_animation_engine.ts","../../../../packages/animations/browser/src/render/web_animations/web_animations_player.ts","../../../../packages/animations/browser/src/render/web_animations/web_animations_driver.ts","../../../../packages/animations/browser/src/render/transition_animation_engine.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_builder.ts","../../../../packages/animations/browser/src/dsl/animation.ts","../../../../packages/animations/browser/src/dsl/style_normalization/animation_style_normalizer.ts","../../../../packages/animations/browser/src/dsl/style_normalization/web_animations_style_normalizer.ts","../../../../packages/animations/browser/src/dsl/animation_transition_factory.ts","../../../../packages/animations/browser/src/dsl/animation_trigger.ts","../../../../packages/animations/browser/src/render/timeline_animation_engine.ts","../../../../packages/animations/browser/src/util.ts","../../../../packages/animations/browser/src/dsl/animation_ast.ts","../../../../packages/animations/browser/src/dsl/animation_ast_builder.ts","../../../../packages/animations/browser/src/dsl/element_instruction_map.ts","../../../../packages/animations/browser/src/render/animation_driver.ts","../../../../packages/animations/browser/src/dsl/animation_transition_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_timeline_instruction.ts","../../../../packages/animations/browser/src/dsl/animation_dsl_visitor.ts","../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts","../../../../packages/animations/browser/src/render/shared.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationPlayer, AnimationTriggerMetadata} from '@angular/animations';\n\nimport {AnimationEngine} from '../animation_engine';\nimport {TriggerAst} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {AnimationTrigger, buildTrigger} from '../dsl/animation_trigger';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\n\nimport {AnimationDriver} from './animation_driver';\nimport {parseTimelineCommand} from './shared';\nimport {TimelineAnimationEngine} from './timeline_animation_engine';\nimport {TransitionAnimationEngine} from './transition_animation_engine';\nexport class DomAnimationEngine implements AnimationEngine {\nprivate _transitionEngine: TransitionAnimationEngine;\nprivate _timelineEngine: TimelineAnimationEngine;\nprivate _triggerCache: {[key: string]: AnimationTrigger} = {};\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} driver\n * @param {?} normalizer\n */\nconstructor(driver: AnimationDriver, normalizer: AnimationStyleNormalizer) {\n    this._transitionEngine = new TransitionAnimationEngine(driver, normalizer);\n    this._timelineEngine = new TimelineAnimationEngine(driver, normalizer);\n\n    this._transitionEngine.onRemovalComplete =\n        (element: any, context: any) => { this.onRemovalComplete(element, context); }\n  }\n/**\n * @param {?} componentId\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} metadata\n * @return {?}\n */\nregisterTrigger(\n      componentId: string, namespaceId: string, hostElement: any, name: string,\n      metadata: AnimationTriggerMetadata): void {\n    const /** @type {?} */ cacheKey = componentId + '-' + name;\n    let /** @type {?} */ trigger = this._triggerCache[cacheKey];\n    if (!trigger) {\n      const /** @type {?} */ errors: any[] = [];\n      const /** @type {?} */ ast = /** @type {?} */(( buildAnimationAst( /** @type {?} */((metadata as AnimationMetadata)), errors) as TriggerAst));\n      if (errors.length) {\n        throw new Error(\n            `The animation trigger \"${name}\" has failed to build due to the following errors:\\n - ${errors.join(\"\\n - \")}`);\n      }\n      trigger = buildTrigger(name, ast);\n      this._triggerCache[cacheKey] = trigger;\n    }\n\n    this._transitionEngine.register(namespaceId, hostElement, name, trigger);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} context\n * @return {?}\n */\ndestroy(namespaceId: string, context: any) {\n    this._transitionEngine.destroy(namespaceId, context);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\nonInsert(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nonRemove(namespaceId: string, element: any, context: any): void {\n    this._transitionEngine.removeNode(namespaceId, element, context);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(namespaceId: string, element: any, property: string, value: any): boolean {\n    // @@property\n    if (property.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(property);\n      const /** @type {?} */ args = /** @type {?} */(( value as any[]));\n      this._timelineEngine.command(id, element, action, args);\n      return false;\n    }\n    return this._transitionEngine.trigger(namespaceId, element, property, value);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, eventName: string, eventPhase: string,\n      callback: (event: any) => any): () => any {\n    // @@listen\n    if (eventName.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(eventName);\n      return this._timelineEngine.listen(id, element, action, callback);\n    }\n    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n  }\n/**\n * @return {?}\n */\nflush(): void { this._transitionEngine.flush(); }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] {\n    return ( /** @type {?} */((this._transitionEngine.players as AnimationPlayer[])))\n        .concat( /** @type {?} */((this._timelineEngine.players as AnimationPlayer[])));\n  }\n}\n\nfunction DomAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nDomAnimationEngine.prototype._transitionEngine;\n/** @type {?} */\nDomAnimationEngine.prototype._timelineEngine;\n/** @type {?} */\nDomAnimationEngine.prototype._triggerCache;\n/** @type {?} */\nDomAnimationEngine.prototype.onRemovalComplete;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationEvent, AnimationPlayer, AnimationTriggerMetadata, ɵStyleData} from '@angular/animations';\n\nimport {AnimationEngine} from '../animation_engine';\nimport {TriggerAst} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {buildTrigger} from '../dsl/animation_trigger';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {copyStyles, eraseStyles, normalizeStyles, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {parseTimelineCommand} from './shared';\nimport {TimelineAnimationEngine} from './timeline_animation_engine';\n\ninterface ListenerTuple {\n  eventPhase: string;\n  triggerName: string;\n  namespacedName: string;\n  callback: (event: any) => any;\n  doRemove?: boolean;\n}\n\ninterface ChangeTuple {\n  element: any;\n  namespacedName: string;\n  triggerName: string;\n  oldValue: string;\n  newValue: string;\n}\n\nconst /** @type {?} */ DEFAULT_STATE_VALUE = 'void';\nconst /** @type {?} */ DEFAULT_STATE_STYLES = '*';\nexport class NoopAnimationEngine extends AnimationEngine {\nprivate _listeners = new Map<any, ListenerTuple[]>();\nprivate _changes: ChangeTuple[] = [];\nprivate _flaggedRemovals = new Set<any>();\nprivate _onDoneFns: (() => any)[] = [];\nprivate _triggerStyles: {[triggerName: string]: {[stateName: string]: ɵStyleData}} =\n      Object.create(null);\nprivate _timelineEngine: TimelineAnimationEngine;\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} driver\n * @param {?} normalizer\n */\nconstructor(driver: AnimationDriver, normalizer: AnimationStyleNormalizer) {\n    super();\n    this._timelineEngine = new TimelineAnimationEngine(driver, normalizer);\n  }\n/**\n * @param {?} componentId\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} metadata\n * @return {?}\n */\nregisterTrigger(\n      componentId: string, namespaceId: string, hostElement: any, name: string,\n      metadata: AnimationTriggerMetadata): void {\n    name = name || metadata.name;\n    name = namespaceId + '#' + name;\n    if (this._triggerStyles[name]) {\n      return;\n    }\n\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = /** @type {?} */(( buildAnimationAst(metadata, errors) as TriggerAst));\n    const /** @type {?} */ trigger = buildTrigger(name, ast);\n    this._triggerStyles[name] = trigger.states;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\nonInsert(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {}\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\nonRemove(namespaceId: string, element: any, context: any): void {\n    this.onRemovalComplete(element, context);\n    if (element['nodeType'] == 1) {\n      this._flaggedRemovals.add(element);\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} property\n * @param {?} value\n * @return {?}\n */\nsetProperty(namespaceId: string, element: any, property: string, value: any): boolean {\n    if (property.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(property);\n      const /** @type {?} */ args = /** @type {?} */(( value as any[]));\n      this._timelineEngine.command(id, element, action, args);\n      return false;\n    }\n\n    const /** @type {?} */ namespacedName = namespaceId + '#' + property;\n    const /** @type {?} */ storageProp = makeStorageProp(namespacedName);\n    const /** @type {?} */ oldValue = element[storageProp] || DEFAULT_STATE_VALUE;\n    this._changes.push( /** @type {?} */((\n        <ChangeTuple>{element, oldValue, newValue: value, triggerName: property, namespacedName})));\n\n    const /** @type {?} */ triggerStateStyles = this._triggerStyles[namespacedName] || {};\n    const /** @type {?} */ fromStateStyles =\n        triggerStateStyles[oldValue] || triggerStateStyles[DEFAULT_STATE_STYLES];\n    if (fromStateStyles) {\n      eraseStyles(element, fromStateStyles);\n    }\n\n    element[storageProp] = value;\n    this._onDoneFns.push(() => {\n      const /** @type {?} */ toStateStyles = triggerStateStyles[value] || triggerStateStyles[DEFAULT_STATE_STYLES];\n      if (toStateStyles) {\n        setStyles(element, toStateStyles);\n      }\n    });\n\n    return true;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} eventName\n * @param {?} eventPhase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, eventName: string, eventPhase: string,\n      callback: (event: any) => any): () => any {\n    if (eventName.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(eventName);\n      return this._timelineEngine.listen(id, element, action, callback);\n    }\n\n    let /** @type {?} */ listeners = this._listeners.get(element);\n    if (!listeners) {\n      this._listeners.set(element, listeners = []);\n    }\n\n    const /** @type {?} */ tuple = /** @type {?} */(( <ListenerTuple>{\n      namespacedName: namespaceId + '#' + eventName,\n      triggerName: eventName, eventPhase, callback\n    }));\n    listeners.push(tuple);\n\n    return () => tuple.doRemove = true;\n  }\n/**\n * @return {?}\n */\nflush(): void {\n    const /** @type {?} */ onStartCallbacks: (() => any)[] = [];\n    const /** @type {?} */ onDoneCallbacks: (() => any)[] = [];\n/**\n * @param {?} listener\n * @param {?} data\n * @return {?}\n */\nfunction handleListener(listener: ListenerTuple, data: ChangeTuple) {\n      const /** @type {?} */ phase = listener.eventPhase;\n      const /** @type {?} */ event = makeAnimationEvent(\n          data.element, data.triggerName, data.oldValue, data.newValue, phase, 0);\n      if (phase == 'start') {\n        onStartCallbacks.push(() => listener.callback(event));\n      } else if (phase == 'done') {\n        onDoneCallbacks.push(() => listener.callback(event));\n      }\n    }\n\n    this._changes.forEach(change => {\n      const /** @type {?} */ element = change.element;\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          if (listener.namespacedName == change.namespacedName) {\n            handleListener(listener, change);\n          }\n        });\n      }\n    });\n\n    // upon removal ALL the animation triggers need to get fired\n    this._flaggedRemovals.forEach(element => {\n      const /** @type {?} */ listeners = this._listeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          const /** @type {?} */ triggerName = listener.triggerName;\n          const /** @type {?} */ namespacedName = listener.namespacedName;\n          const /** @type {?} */ storageProp = makeStorageProp(namespacedName);\n          handleListener(listener, /** @type {?} */(( <ChangeTuple>{\n            element,\n            triggerName,\n            namespacedName: listener.namespacedName,\n            oldValue: element[storageProp] || DEFAULT_STATE_VALUE,\n            newValue: DEFAULT_STATE_VALUE\n          })));\n        });\n      }\n    });\n\n    // remove all the listeners after everything is complete\n    Array.from(this._listeners.keys()).forEach(element => {\n      const /** @type {?} */ listenersToKeep = /** @type {?} */(( this._listeners.get(element))).filter(l => !l.doRemove);\n      if (listenersToKeep.length) {\n        this._listeners.set(element, listenersToKeep);\n      } else {\n        this._listeners.delete(element);\n      }\n    });\n\n    onStartCallbacks.forEach(fn => fn());\n    onDoneCallbacks.forEach(fn => fn());\n    this._flaggedRemovals.clear();\n    this._changes = [];\n\n    this._onDoneFns.forEach(doneFn => doneFn());\n    this._onDoneFns = [];\n  }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] { return []; }\n/**\n * @param {?} namespaceId\n * @return {?}\n */\ndestroy(namespaceId: string) {}\n}\n\nfunction NoopAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopAnimationEngine.prototype._listeners;\n/** @type {?} */\nNoopAnimationEngine.prototype._changes;\n/** @type {?} */\nNoopAnimationEngine.prototype._flaggedRemovals;\n/** @type {?} */\nNoopAnimationEngine.prototype._onDoneFns;\n/** @type {?} */\nNoopAnimationEngine.prototype._triggerStyles;\n/** @type {?} */\nNoopAnimationEngine.prototype._timelineEngine;\n/** @type {?} */\nNoopAnimationEngine.prototype.onRemovalComplete;\n}\n\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} phaseName\n * @param {?} totalTime\n * @return {?}\n */\nfunction makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string,\n    totalTime: number): AnimationEvent {\n  return /** @type {?} */(( <AnimationEvent>{element, triggerName, fromState, toState, phaseName, totalTime}));\n}\n/**\n * @param {?} property\n * @return {?}\n */\nfunction makeStorageProp(property: string): string {\n  return '_@_' + property;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer} from '@angular/animations';\n\nimport {copyStyles, eraseStyles, setStyles} from '../../util';\n\nimport {DOMAnimation} from './dom_animation';\nexport class WebAnimationsPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _onDestroyFns: Function[] = [];\nprivate _player: DOMAnimation;\nprivate _duration: number;\nprivate _delay: number;\nprivate _initialized = false;\nprivate _finished = false;\nprivate _started = false;\nprivate _destroyed = false;\nprivate _finalKeyframe: {[key: string]: string | number};\npublic time = 0;\npublic parentPlayer: AnimationPlayer|null = null;\npublic previousStyles: {[styleName: string]: string | number};\npublic currentSnapshot: {[styleName: string]: string | number} = {};\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @param {?=} previousPlayers\n */\nconstructor(\npublic element: any,\npublic keyframes: {[key: string]: string | number}[],\npublic options: {[key: string]: string | number},\nprivate previousPlayers: WebAnimationsPlayer[] = []) {\n    this._duration = <number>options['duration'];\n    this._delay = <number>options['delay'] || 0;\n    this.time = this._duration + this._delay;\n\n    this.previousStyles = {};\n    previousPlayers.forEach(player => {\n      let styles = player.currentSnapshot;\n      Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n    });\n  }\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @return {?}\n */\ninit(): void {\n    if (this._initialized) return;\n    this._initialized = true;\n\n    const /** @type {?} */ keyframes = this.keyframes.map(styles => copyStyles(styles, false));\n    const /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);\n    if (previousStyleProps.length) {\n      let /** @type {?} */ startingKeyframe = keyframes[0];\n      let /** @type {?} */ missingStyleProps: string[] = [];\n      previousStyleProps.forEach(prop => {\n        if (!startingKeyframe.hasOwnProperty(prop)) {\n          missingStyleProps.push(prop);\n        }\n        startingKeyframe[prop] = this.previousStyles[prop];\n      });\n\n      if (missingStyleProps.length) {\n        const /** @type {?} */ self = this;\n        // tslint:disable-next-line\n        for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {\n          let /** @type {?} */ kf = keyframes[i];\n          missingStyleProps.forEach(function(prop) {\n            kf[prop] = _computeStyle(self.element, prop);\n          });\n        }\n      }\n    }\n\n    this._player = this._triggerWebAnimation(this.element, keyframes, this.options);\n    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};\n\n    // this is required so that the player doesn't start to animate right away\n    if (this._delay) {\n      this._resetDomPlayerState();\n    } else {\n      this._player.pause();\n    }\n    this._player.addEventListener('finish', () => this._onFinish());\n  }\n/**\n * \\@internal\n * @param {?} element\n * @param {?} keyframes\n * @param {?} options\n * @return {?}\n */\n_triggerWebAnimation(element: any, keyframes: any[], options: any): DOMAnimation {\n    // jscompiler doesn't seem to know animate is a native property because it's not fully\n    // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\n    return /** @type {?} */(( element['animate'](keyframes, options) as DOMAnimation));\n  }\n/**\n * @return {?}\n */\nget domPlayer() { return this._player; }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nplay(): void {\n    this.init();\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n    }\n    this._player.play();\n  }\n/**\n * @return {?}\n */\npause(): void {\n    this.init();\n    this._player.pause();\n  }\n/**\n * @return {?}\n */\nfinish(): void {\n    this.init();\n    this._onFinish();\n    this._player.finish();\n  }\n/**\n * @return {?}\n */\nreset(): void {\n    this._resetDomPlayerState();\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n/**\n * @return {?}\n */\nprivate _resetDomPlayerState() {\n    if (this._player) {\n      this._player.cancel();\n    }\n  }\n/**\n * @return {?}\n */\nrestart(): void {\n    this.reset();\n    this.play();\n  }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this._started; }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (!this._destroyed) {\n      this._resetDomPlayerState();\n      this._onFinish();\n      this._destroyed = true;\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void { this._player.currentTime = p * this.time; }\n/**\n * @return {?}\n */\ngetPosition(): number { return this._player.currentTime / this.time; }\n/**\n * @return {?}\n */\nget totalTime(): number { return this._delay + this._duration; }\n/**\n * @return {?}\n */\nbeforeDestroy() {\n    const /** @type {?} */ styles: {[key: string]: string | number} = {};\n    if (this.hasStarted()) {\n      Object.keys(this._finalKeyframe).forEach(prop => {\n        if (prop != 'offset') {\n          styles[prop] =\n              this._finished ? this._finalKeyframe[prop] : _computeStyle(this.element, prop);\n        }\n      });\n    }\n    this.currentSnapshot = styles;\n  }\n}\n\nfunction WebAnimationsPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDoneFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onStartFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._onDestroyFns;\n/** @type {?} */\nWebAnimationsPlayer.prototype._player;\n/** @type {?} */\nWebAnimationsPlayer.prototype._duration;\n/** @type {?} */\nWebAnimationsPlayer.prototype._delay;\n/** @type {?} */\nWebAnimationsPlayer.prototype._initialized;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finished;\n/** @type {?} */\nWebAnimationsPlayer.prototype._started;\n/** @type {?} */\nWebAnimationsPlayer.prototype._destroyed;\n/** @type {?} */\nWebAnimationsPlayer.prototype._finalKeyframe;\n/** @type {?} */\nWebAnimationsPlayer.prototype.time;\n/** @type {?} */\nWebAnimationsPlayer.prototype.parentPlayer;\n/** @type {?} */\nWebAnimationsPlayer.prototype.previousStyles;\n/** @type {?} */\nWebAnimationsPlayer.prototype.currentSnapshot;\n/** @type {?} */\nWebAnimationsPlayer.prototype.element;\n/** @type {?} */\nWebAnimationsPlayer.prototype.keyframes;\n/** @type {?} */\nWebAnimationsPlayer.prototype.options;\n/** @type {?} */\nWebAnimationsPlayer.prototype.previousPlayers;\n}\n\n/**\n * @param {?} element\n * @param {?} prop\n * @return {?}\n */\nfunction _computeStyle(element: any, prop: string): string {\n  return ( /** @type {?} */((<any>window.getComputedStyle(element))))[prop];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../animation_driver';\n\nimport {WebAnimationsPlayer} from './web_animations_player';\nexport class WebAnimationsDriver implements AnimationDriver {\n/**\n * @param {?} element\n * @param {?} prop\n * @param {?=} defaultValue\n * @return {?}\n */\ncomputeStyle(element: any, prop: string, defaultValue?: string): string {\n    return /** @type {?} */(( ( /** @type {?} */((window.getComputedStyle(element) as any)))[prop] as string));\n  }\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?=} previousPlayers\n * @return {?}\n */\nanimate(\n      element: any, keyframes: ɵStyleData[], duration: number, delay: number, easing: string,\n      previousPlayers: AnimationPlayer[] = []): WebAnimationsPlayer {\n    const /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';\n    const /** @type {?} */ playerOptions: {[key: string]: string | number} = {duration, delay, fill};\n\n    // we check for this to avoid having a null|undefined value be present\n    // for the easing (which results in an error for certain browsers #9752)\n    if (easing) {\n      playerOptions['easing'] = easing;\n    }\n\n    const /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */(( <WebAnimationsPlayer[]>previousPlayers.filter(\n        player => { return player instanceof WebAnimationsPlayer; })));\n    return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);\n  }\n}\n/**\n * @return {?}\n */\nexport function supportsWebAnimations() {\n  return typeof Element !== 'undefined' && typeof( /** @type {?} */((<any>Element))).prototype['animate'] === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionFactory} from '../dsl/animation_transition_factory';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger} from '../dsl/animation_trigger';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {ENTER_CLASSNAME, LEAVE_CLASSNAME, LEAVE_SELECTOR, NG_ANIMATING_CLASSNAME, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, eraseStyles, iteratorToArray, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst /** @type {?} */ EMPTY_PLAYER_ARRAY: AnimationPlayer[] = [];\n\ninterface TriggerListener {\n  name: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nexport interface QueueInstruction {\n  element: any;\n  triggerName: string;\n  fromState: StateValue;\n  toState: StateValue;\n  transition: AnimationTransitionFactory;\n  player: TransitionAnimationPlayer;\n  isFallbackTransition: boolean;\n}\nexport class StateValue {\npublic value: string;\npublic data: {[key: string]: any};\n/**\n * @param {?} input\n */\nconstructor(input: any) {\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    this.data = isObj ? input : {value: value};\n  }\n/**\n * @param {?} values\n * @return {?}\n */\nabsorbValues(values: {[key: string]: any}) {\n    Object.keys(values).forEach(prop => {\n      if (this.data[prop] == null) {\n        this.data[prop] = values[prop];\n      }\n    });\n  }\n}\n\nfunction StateValue_tsickle_Closure_declarations() {\n/** @type {?} */\nStateValue.prototype.value;\n/** @type {?} */\nStateValue.prototype.data;\n}\n\n\nexport const /** @type {?} */ VOID_VALUE = 'void';\nexport const /** @type {?} */ DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\nexport const /** @type {?} */ DELETED_STATE_VALUE = new StateValue('DELETED');\n\nconst /** @type {?} */ POTENTIAL_ENTER_CLASSNAME = ENTER_CLASSNAME + '-temp';\nconst /** @type {?} */ POTENTIAL_ENTER_SELECTOR = '.' + POTENTIAL_ENTER_CLASSNAME;\nexport class AnimationTransitionNamespace {\npublic players: TransitionAnimationPlayer[] = [];\nprivate _triggers: {[triggerName: string]: AnimationTrigger} = {};\nprivate _queue: QueueInstruction[] = [];\nprivate _elementListeners = new Map<any, TriggerListener[]>();\nprivate _hostClassName: string;\n/**\n * @param {?} id\n * @param {?} hostElement\n * @param {?} _engine\n */\nconstructor(\npublic id: string,\npublic hostElement: any,\nprivate _engine: TransitionAnimationEngine) {\n    this._hostClassName = 'ng-tns-' + id;\n    hostElement.classList.add(this._hostClassName);\n  }\n/**\n * @param {?} element\n * @param {?} name\n * @param {?} phase\n * @param {?} callback\n * @return {?}\n */\nlisten(element: any, name: string, phase: string, callback: (event: any) => boolean): () => any {\n    if (!this._triggers.hasOwnProperty(name)) {\n      throw new Error(\n          `Unable to listen on the animation trigger event \"${phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n    }\n\n    if (phase == null || phase.length == 0) {\n      throw new Error(\n          `Unable to listen on the animation trigger \"${name}\" because the provided event is undefined!`);\n    }\n\n    if (!isTriggerEventValid(phase)) {\n      throw new Error(\n          `The provided animation trigger event \"${phase}\" for the animation trigger \"${name}\" is not supported!`);\n    }\n\n    const /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);\n    const /** @type {?} */ data = {name, phase, callback};\n    listeners.push(data);\n\n    const /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n    if (!triggersWithStates.hasOwnProperty(name)) {\n      element.classList.add(NG_TRIGGER_CLASSNAME);\n      element.classList.add(NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates[name] = null;\n    }\n\n    return () => {\n      // the event listener is removed AFTER the flush has occurred such\n      // that leave animations callbacks can fire (otherwise if the node\n      // is removed in between then the listeners would be deregistered)\n      this._engine.afterFlush(() => {\n        const /** @type {?} */ index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n\n        if (!this._triggers[name]) {\n          delete triggersWithStates[name];\n        }\n      });\n    };\n  }\n/**\n * @param {?} name\n * @param {?} ast\n * @return {?}\n */\nregister(name: string, ast: AnimationTrigger): boolean {\n    if (this._triggers[name]) {\n      // throw\n      return false;\n    } else {\n      this._triggers[name] = ast;\n      return true;\n    }\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nprivate _getTrigger(name: string) {\n    const /** @type {?} */ trigger = this._triggers[name];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${name}\" has not been registered!`);\n    }\n    return trigger;\n  }\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} value\n * @param {?=} defaultToFallback\n * @return {?}\n */\ntrigger(element: any, triggerName: string, value: any, defaultToFallback: boolean = true):\n      TransitionAnimationPlayer|undefined {\n    const /** @type {?} */ trigger = this._getTrigger(triggerName);\n    const /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n    let /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      element.classList.add(NG_TRIGGER_CLASSNAME);\n      element.classList.add(NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = {});\n    }\n\n    let /** @type {?} */ fromState = triggersWithStates[triggerName];\n    const /** @type {?} */ toState = new StateValue(value);\n\n    const /** @type {?} */ isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbValues(fromState.data);\n    }\n\n    triggersWithStates[triggerName] = toState;\n\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    } else if (fromState === DELETED_STATE_VALUE) {\n      return player;\n    }\n\n    const /** @type {?} */ playersOnElement: TransitionAnimationPlayer[] =\n        getOrSetAsInMap(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      // only remove the player if it is queued on the EXACT same trigger/namespace\n      // we only also deal with queued players here because if the animation has\n      // started then we want to keep the player alive until the flush happens\n      // (which is where the previousPlayers are passed into the new palyer)\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n\n    let /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);\n    let /** @type {?} */ isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n\n    this._engine.totalQueuedPlayers++;\n    this._queue.push(\n        {element, triggerName, transition, fromState, toState, player, isFallbackTransition});\n\n    if (!isFallbackTransition) {\n      element.classList.add(NG_ANIMATING_CLASSNAME);\n    }\n\n    player.onDone(() => {\n      element.classList.remove(NG_ANIMATING_CLASSNAME);\n\n      let /** @type {?} */ index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n\n      const /** @type {?} */ players = this._engine.playersByElement.get(element);\n      if (players) {\n        let /** @type {?} */ index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n\n    this.players.push(player);\n    playersOnElement.push(player);\n\n    return player;\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nderegister(name: string) {\n    delete this._triggers[name];\n\n    this._engine.statesByElement.forEach((stateMap, element) => { delete stateMap[name]; });\n\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(\n          element, listeners.filter(entry => { return entry.name != name; }));\n    });\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nprivate _onElementDestroy(element: any) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n/**\n * @param {?} rootElement\n * @param {?} context\n * @param {?=} animate\n * @return {?}\n */\nprivate _destroyInnerNodes(rootElement: any, context: any, animate: boolean = false) {\n    listToArray(rootElement.querySelectorAll(NG_TRIGGER_SELECTOR)).forEach(elm => {\n      if (animate && elm.classList.contains(this._hostClassName)) {\n        const /** @type {?} */ innerNs = this._engine.namespacesByHostElement.get(elm);\n\n        // special case for a host element with animations on the same element\n        if (innerNs) {\n          innerNs.removeNode(elm, context, true);\n        }\n\n        this.removeNode(elm, context, true);\n      } else {\n        this._onElementDestroy(elm);\n      }\n    });\n  }\n/**\n * @param {?} element\n * @param {?} context\n * @param {?=} doNotRecurse\n * @return {?}\n */\nremoveNode(element: any, context: any, doNotRecurse?: boolean): void {\n    const /** @type {?} */ engine = this._engine;\n\n    element.classList.add(LEAVE_CLASSNAME);\n    engine.afterFlush(() => element.classList.remove(LEAVE_CLASSNAME));\n\n    if (!doNotRecurse && element.childElementCount) {\n      this._destroyInnerNodes(element, context, true);\n    }\n\n    const /** @type {?} */ triggerStates = engine.statesByElement.get(element);\n    if (triggerStates) {\n      const /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n      Object.keys(triggerStates).forEach(triggerName => {\n        // this check is here in the event that an element is removed\n        // twice (both on the host level and the component level)\n        if (this._triggers[triggerName]) {\n          const /** @type {?} */ player = this.trigger(element, triggerName, VOID_VALUE, false);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => {\n          engine.destroyInnerAnimations(element);\n          this._onElementDestroy(element);\n          engine._onRemovalComplete(element, context);\n        });\n\n        return;\n      }\n    }\n\n    // find the player that is animating and make sure that the\n    // removal is delayed until that player has completed\n    let /** @type {?} */ containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const /** @type {?} */ currentPlayers =\n          engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n\n      // when this `if statement` does not continue forward it means that\n      // a previous animation query has selected the current element and\n      // is animating it. In this situation want to continue fowards and\n      // allow the element to be queued up for animation later.\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let /** @type {?} */ parent = element;\n        while (parent = parent.parentNode) {\n          const /** @type {?} */ triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // at this stage we know that the element will either get removed\n    // during flush or will be picked up by a parent query. Either way\n    // we need to fire the listeners for this element when it DOES get\n    // removed (once the query parent animation is done or after flush)\n    const /** @type {?} */ listeners = this._elementListeners.get(element);\n    if (listeners) {\n      const /** @type {?} */ visitedTriggers = new Set<string>();\n      listeners.forEach(listener => {\n        const /** @type {?} */ triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n\n        const /** @type {?} */ trigger = this._triggers[triggerName];\n        const /** @type {?} */ transition = trigger.fallbackTransition;\n        const /** @type {?} */ elementStates = /** @type {?} */(( engine.statesByElement.get(element)));\n        const /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\n        const /** @type {?} */ toState = new StateValue(VOID_VALUE);\n        const /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n\n    // whether or not a parent has an animation we need to delay the deferral of the leave\n    // operation until we have more information (which we do after flush() has been called)\n    if (containsPotentialParentTransition) {\n      engine.queuedRemovals.set(element, () => {\n        engine.destroyInnerAnimations(element);\n        this._onElementDestroy(element);\n        engine._onRemovalComplete(element, context);\n      });\n    } else {\n      // we do this after the flush has occurred such\n      // that the callbacks can be fired\n      engine.afterFlush(() => this._onElementDestroy(element));\n      engine.destroyInnerAnimations(element);\n      engine._onRemovalComplete(element, context);\n    }\n  }\n/**\n * @param {?} element\n * @param {?} parent\n * @return {?}\n */\ninsertNode(element: any, parent: any): void { element.classList.add(this._hostClassName); }\n/**\n * @return {?}\n */\ndrainQueuedTransitions(): QueueInstruction[] {\n    const /** @type {?} */ instructions: QueueInstruction[] = [];\n    this._queue.forEach(entry => {\n      const /** @type {?} */ player = entry.player;\n      if (player.destroyed) return;\n\n      const /** @type {?} */ element = entry.element;\n      const /** @type {?} */ listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach((listener: TriggerListener) => {\n          if (listener.name == entry.triggerName) {\n            const /** @type {?} */ baseEvent = makeAnimationEvent(\n                element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          // now we can destroy the element properly since the event listeners have\n          // been bound to the player\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n\n    this._queue = [];\n\n    return instructions.sort((a, b) => {\n      // if depCount == 0 them move to front\n      // otherwise if a.contains(b) then move back\n      const /** @type {?} */ d0 = a.transition.ast.depCount;\n      const /** @type {?} */ d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return a.element.contains(b.element) ? 1 : -1;\n    });\n  }\n/**\n * @param {?} context\n * @return {?}\n */\ndestroy(context: any) {\n    this.players.forEach(p => p.destroy());\n    this._destroyInnerNodes(this.hostElement, context);\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nelementContainsData(element: any): boolean {\n    let /** @type {?} */ containsData = false;\n    if (this._elementListeners.has(element)) containsData = true;\n    containsData =\n        (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n    return containsData;\n  }\n}\n\nfunction AnimationTransitionNamespace_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionNamespace.prototype.players;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._triggers;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._queue;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._elementListeners;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._hostClassName;\n/** @type {?} */\nAnimationTransitionNamespace.prototype.id;\n/** @type {?} */\nAnimationTransitionNamespace.prototype.hostElement;\n/** @type {?} */\nAnimationTransitionNamespace.prototype._engine;\n}\n\n\nexport interface QueuedTransition {\n  element: any;\n  instruction: AnimationTransitionInstruction;\n  player: TransitionAnimationPlayer;\n}\nexport class TransitionAnimationEngine {\npublic players: TransitionAnimationPlayer[] = [];\npublic queuedRemovals = new Map<any, () => any>();\npublic newlyInserted = new Set<any>();\npublic newHostElements = new Map<any, AnimationTransitionNamespace>();\npublic playersByElement = new Map<any, TransitionAnimationPlayer[]>();\npublic playersByQueriedElement = new Map<any, TransitionAnimationPlayer[]>();\npublic statesByElement = new Map<any, {[triggerName: string]: StateValue}>();\npublic totalAnimations = 0;\npublic totalQueuedPlayers = 0;\nprivate _namespaceLookup: {[id: string]: AnimationTransitionNamespace} = {};\nprivate _namespaceList: AnimationTransitionNamespace[] = [];\nprivate _flushFns: (() => any)[] = [];\nprivate _whenQuietFns: (() => any)[] = [];\npublic namespacesByHostElement = new Map<any, AnimationTransitionNamespace>();\npublic onRemovalComplete = (element: any, context: any) => {};\n/**\n * @param {?} element\n * @param {?} context\n * @return {?}\n */\n_onRemovalComplete(element: any, context: any) { this.onRemovalComplete(element, context); }\n/**\n * @param {?} _driver\n * @param {?} _normalizer\n */\nconstructor(private _driver: AnimationDriver,\nprivate _normalizer: AnimationStyleNormalizer) {}\n/**\n * @return {?}\n */\nget queuedPlayers(): TransitionAnimationPlayer[] {\n    const /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} hostElement\n * @return {?}\n */\ncreateNamespace(namespaceId: string, hostElement: any) {\n    const /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (hostElement.parentNode) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      // defer this later until flush during when the host element has\n      // been inserted so that we know exactly where to place it in\n      // the namespace list\n      this.newHostElements.set(hostElement, ns);\n\n      // given that this host element is apart of the animation code, it\n      // may or may not be inserted by a parent node that is an of an\n      // animation renderer type. If this happens then we can still have\n      // access to this item when we query for :enter nodes. If the parent\n      // is a renderer then the set data-structure will normalize the entry\n      this.newlyInserted.add(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n/**\n * @param {?} ns\n * @param {?} hostElement\n * @return {?}\n */\nprivate _balanceNamespaceList(ns: AnimationTransitionNamespace, hostElement: any) {\n    const /** @type {?} */ limit = this._namespaceList.length - 1;\n    if (limit >= 0) {\n      let /** @type {?} */ found = false;\n      for (let /** @type {?} */ i = limit; i >= 0; i--) {\n        const /** @type {?} */ nextNamespace = this._namespaceList[i];\n        if (nextNamespace.hostElement.contains(hostElement)) {\n          this._namespaceList.splice(i + 1, 0, ns);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        this._namespaceList.splice(0, 0, ns);\n      }\n    } else {\n      this._namespaceList.push(ns);\n    }\n\n    this.namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} hostElement\n * @param {?} name\n * @param {?} trigger\n * @return {?}\n */\nregister(namespaceId: string, hostElement: any, name: string, trigger: AnimationTrigger) {\n    let /** @type {?} */ ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    if (ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} context\n * @return {?}\n */\ndestroy(namespaceId: string, context: any) {\n    const /** @type {?} */ ns = this._fetchNamespace(namespaceId);\n\n    this.afterFlush(() => {\n      this.namespacesByHostElement.delete(ns.hostElement);\n      delete this._namespaceLookup[namespaceId];\n      const /** @type {?} */ index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n    });\n\n    this.afterFlushAnimationsDone(() => ns.destroy(context));\n  }\n/**\n * @param {?} id\n * @return {?}\n */\nprivate _fetchNamespace(id: string) { return this._namespaceLookup[id]; }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\ntrigger(namespaceId: string, element: any, name: string, value: any): boolean {\n    if (isElementNode(element)) {\n      this._fetchNamespace(namespaceId).trigger(element, name, value);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} parent\n * @param {?} insertBefore\n * @return {?}\n */\ninsertNode(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    if (!isElementNode(element)) return;\n\n    this._fetchNamespace(namespaceId).insertNode(element, parent);\n\n    // only *directives and host elements are inserted before\n    if (insertBefore) {\n      this.newlyInserted.add(element);\n    }\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} context\n * @param {?=} doNotRecurse\n * @return {?}\n */\nremoveNode(namespaceId: string, element: any, context: any, doNotRecurse?: boolean): void {\n    if (!isElementNode(element)) {\n      this._onRemovalComplete(element, context);\n      return;\n    }\n\n    this._fetchNamespace(namespaceId).removeNode(element, context, doNotRecurse);\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @param {?} name\n * @param {?} phase\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      namespaceId: string, element: any, name: string, phase: string,\n      callback: (event: any) => boolean): () => any {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n/**\n * @param {?} entry\n * @param {?} subTimelines\n * @return {?}\n */\nprivate _buildInstruction(entry: QueueInstruction, subTimelines: ElementInstructionMap) {\n    return entry.transition.build(\n        entry.element, entry.fromState.value, entry.toState.value, entry.toState.data,\n        subTimelines);\n  }\n/**\n * @param {?} containerElement\n * @return {?}\n */\ndestroyInnerAnimations(containerElement: any) {\n    listToArray(containerElement.querySelectorAll(NG_TRIGGER_SELECTOR)).forEach(element => {\n      const /** @type {?} */ players = this.playersByElement.get(element);\n      if (players) {\n        players.forEach(player => {\n          // special case for when an element is set for destruction, but hasn't started.\n          // in this situation we want to delay the destruction until the flush occurs\n          // so that any event listeners attached to the player are triggered.\n          if (player.queued) {\n            player.markedForDestroy = true;\n          } else {\n            player.destroy();\n          }\n        });\n      }\n      const /** @type {?} */ stateMap = this.statesByElement.get(element);\n      if (stateMap) {\n        Object.keys(stateMap).forEach(triggerName => stateMap[triggerName] = DELETED_STATE_VALUE);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nflush() {\n    let /** @type {?} */ players: AnimationPlayer[] = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => { this._balanceNamespaceList(ns, element); });\n      this.newHostElements.clear();\n    }\n\n    if (this._namespaceList.length && (this.totalQueuedPlayers || this.queuedRemovals.size)) {\n      players = this._flushAnimations();\n    }\n\n    this.totalQueuedPlayers = 0;\n    this.queuedRemovals.clear();\n    this.newlyInserted.clear();\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n\n    if (this._whenQuietFns.length) {\n      // we move these over to a variable so that\n      // if any new callbacks are registered in another\n      // flush they do not populate the existing set\n      const /** @type {?} */ quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => { quietFns.forEach(fn => fn()); });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n/**\n * @return {?}\n */\nprivate _flushAnimations(): TransitionAnimationPlayer[] {\n    const /** @type {?} */ subTimelines = new ElementInstructionMap();\n    const /** @type {?} */ skippedPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ skippedPlayersMap = new Map<any, AnimationPlayer[]>();\n    const /** @type {?} */ queuedInstructions: QueuedTransition[] = [];\n    const /** @type {?} */ queriedElements = new Map<any, TransitionAnimationPlayer[]>();\n    const /** @type {?} */ allPreStyleElements = new Map<any, Set<string>>();\n    const /** @type {?} */ allPostStyleElements = new Map<any, Set<string>>();\n\n    // this must occur before the instructions are built below such that\n    // the :enter queries match the elements (since the timeline queries\n    // are fired during instruction building).\n    const /** @type {?} */ allEnterNodes = iteratorToArray(this.newlyInserted.values());\n    const /** @type {?} */ enterNodes: any[] = collectEnterElements(allEnterNodes);\n\n    for (let /** @type {?} */ i = this._namespaceList.length - 1; i >= 0; i--) {\n      const /** @type {?} */ ns = this._namespaceList[i];\n      ns.drainQueuedTransitions().forEach(entry => {\n        const /** @type {?} */ player = entry.player;\n        const /** @type {?} */ element = entry.element;\n        if (!document.body.contains(element)) {\n          player.destroy();\n          return;\n        }\n\n        const /** @type {?} */ instruction = this._buildInstruction(entry, subTimelines);\n        if (!instruction) return;\n\n        // if a unmatched transition is queued to go then it SHOULD NOT render\n        // an animation and cancel the previously running animations.\n        if (entry.isFallbackTransition && !instruction.isRemovalTransition) {\n          eraseStyles(element, instruction.fromStyles);\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this means that if a parent animation uses this animation as a sub trigger\n        // then it will instruct the timeline builder to not add a player delay, but\n        // instead stretch the first keyframe gap up until the animation starts. The\n        // reason this is important is to prevent extra initialization styles from being\n        // required by the user in the animation.\n        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n\n        subTimelines.append(element, instruction.timelines);\n\n        const /** @type {?} */ tuple = {instruction, player, element};\n\n        queuedInstructions.push(tuple);\n\n        instruction.queriedElements.forEach(\n            element => getOrSetAsInMap(queriedElements, element, []).push(player));\n\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          const /** @type {?} */ props = Object.keys(stringMap);\n          if (props.length) {\n            let /** @type {?} */ setVal: Set<string> = /** @type {?} */(( allPreStyleElements.get(element)));\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set<string>());\n            }\n            props.forEach(prop => setVal.add(prop));\n          }\n        });\n\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          const /** @type {?} */ props = Object.keys(stringMap);\n          let /** @type {?} */ setVal: Set<string> = /** @type {?} */(( allPostStyleElements.get(element)));\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set<string>());\n          }\n          props.forEach(prop => setVal.add(prop));\n        });\n      });\n    }\n\n    const /** @type {?} */ allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n    let /** @type {?} */ sortedParentElements: any[] = [];\n    queuedInstructions.forEach(entry => {\n      const /** @type {?} */ element = entry.element;\n      if (subTimelines.has(element)) {\n        sortedParentElements.unshift(element);\n        this._beforeAnimationBuild(\n            entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n\n    allPreviousPlayersMap.forEach(players => { players.forEach(player => player.destroy()); });\n\n    const /** @type {?} */ leaveNodes: any[] = allPostStyleElements.size ?\n        listToArray(document.body.querySelectorAll(LEAVE_SELECTOR)) :\n        [];\n\n    // PRE STAGE: fill the ! styles\n    const /** @type {?} */ preStylesMap = allPreStyleElements.size ?\n        cloakAndComputeStyles(this._driver, enterNodes, allPreStyleElements, PRE_STYLE) :\n        new Map<any, ɵStyleData>();\n\n    // POST STAGE: fill the * styles\n    const /** @type {?} */ postStylesMap =\n        cloakAndComputeStyles(this._driver, leaveNodes, allPostStyleElements, AUTO_STYLE);\n\n    const /** @type {?} */ rootPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ subPlayers: TransitionAnimationPlayer[] = [];\n    queuedInstructions.forEach(entry => {\n      const {element, player, instruction} = entry;\n      // this means that it was never consumed by a parent animation which\n      // means that it is independent and therefore should be set for animation\n      if (subTimelines.has(element)) {\n        const /** @type {?} */ innerPlayer = this._buildAnimation(\n            player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap,\n            postStylesMap);\n        player.setRealPlayer(innerPlayer);\n\n        let /** @type {?} */ parentHasPriority: any = null;\n        for (let /** @type {?} */ i = 0; i < sortedParentElements.length; i++) {\n          const /** @type {?} */ parent = sortedParentElements[i];\n          if (parent === element) break;\n          if (parent.contains(element)) {\n            parentHasPriority = parent;\n            break;\n          }\n        }\n\n        if (parentHasPriority) {\n          const /** @type {?} */ parentPlayers = this.playersByElement.get(parentHasPriority);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        } else {\n          rootPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        subPlayers.push(player);\n      }\n    });\n\n    subPlayers.forEach(player => {\n      const /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n\n    // the reason why we don't actually play the animation is\n    // because all that a skipped player is designed to do is to\n    // fire the start/done transition callback events\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.parentPlayer.onDestroy(() => player.destroy());\n      } else {\n        player.destroy();\n      }\n    });\n\n    // run through all of the queued removals and see if they\n    // were picked up by a query. If not then perform the removal\n    // operation right away unless a parent animation is ongoing.\n    this.queuedRemovals.forEach((fn, element) => {\n      const /** @type {?} */ players = queriedElements.get(element);\n      if (players) {\n        optimizeGroupPlayer(players).onDone(fn);\n      } else {\n        let /** @type {?} */ elementPlayers: AnimationPlayer[]|null = null;\n\n        let /** @type {?} */ parent = element;\n        while (parent = parent.parentNode) {\n          const /** @type {?} */ playersForThisElement = this.playersByElement.get(parent);\n          if (playersForThisElement && playersForThisElement.length) {\n            elementPlayers = playersForThisElement;\n            break;\n          }\n        }\n\n        if (elementPlayers) {\n          optimizeGroupPlayer(elementPlayers).onDone(fn);\n        } else {\n          fn();\n        }\n      }\n    });\n\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n\n        const /** @type {?} */ index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n\n    enterNodes.forEach(element => element.classList.remove(ENTER_CLASSNAME));\n\n    return rootPlayers;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} element\n * @return {?}\n */\nelementContainsData(namespaceId: string, element: any) {\n    let /** @type {?} */ containsData = false;\n    if (this.queuedRemovals.has(element)) containsData = true;\n    if (this.newlyInserted.has(element)) containsData = true;\n    if (this.playersByElement.has(element)) containsData = true;\n    if (this.playersByQueriedElement.has(element)) containsData = true;\n    if (this.statesByElement.has(element)) containsData = true;\n    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n  }\n/**\n * @param {?} callback\n * @return {?}\n */\nafterFlush(callback: () => any) { this._flushFns.push(callback); }\n/**\n * @param {?} callback\n * @return {?}\n */\nafterFlushAnimationsDone(callback: () => any) { this._whenQuietFns.push(callback); }\n/**\n * @param {?} element\n * @param {?} instruction\n * @param {?} isQueriedElement\n * @param {?=} namespaceId\n * @param {?=} triggerName\n * @return {?}\n */\nprivate _getPreviousPlayers(\n      element: string, instruction: AnimationTransitionInstruction, isQueriedElement: boolean,\n      namespaceId?: string, triggerName?: string): TransitionAnimationPlayer[] {\n    let /** @type {?} */ players: TransitionAnimationPlayer[] = [];\n    if (isQueriedElement) {\n      const /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const /** @type {?} */ elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const /** @type {?} */ isRemovalAnimation = instruction.toState == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != instruction.triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      })\n    }\n    return players;\n  }\n/**\n * @param {?} namespaceId\n * @param {?} instruction\n * @param {?} allPreviousPlayersMap\n * @return {?}\n */\nprivate _beforeAnimationBuild(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>) {\n    // it's important to do this step before destroying the players\n    // so that the onDone callback below won't fire before this\n    eraseStyles(instruction.element, instruction.fromStyles);\n\n    const /** @type {?} */ triggerName = instruction.triggerName;\n    const /** @type {?} */ rootElement = instruction.element;\n\n    // when a removal animation occurs, ALL previous players are collected\n    // and destroyed (even if they are outside of the current namespace)\n    const /** @type {?} */ targetNameSpaceId: string|undefined =\n        instruction.isRemovalTransition ? undefined : namespaceId;\n    const /** @type {?} */ targetTriggerName: string|undefined =\n        instruction.isRemovalTransition ? undefined : triggerName;\n\n    instruction.timelines.map(timelineInstruction => {\n      const /** @type {?} */ element = timelineInstruction.element;\n      const /** @type {?} */ isQueriedElement = element !== rootElement;\n      const /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n      const /** @type {?} */ previousPlayers = this._getPreviousPlayers(\n          element, instruction, isQueriedElement, targetNameSpaceId, targetTriggerName);\n      previousPlayers.forEach(player => {\n        const /** @type {?} */ realPlayer = /** @type {?} */(( player.getRealPlayer() as any));\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        players.push(player);\n      });\n    });\n  }\n/**\n * @param {?} namespaceId\n * @param {?} instruction\n * @param {?} allPreviousPlayersMap\n * @param {?} skippedPlayersMap\n * @param {?} preStylesMap\n * @param {?} postStylesMap\n * @return {?}\n */\nprivate _buildAnimation(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>,\n      skippedPlayersMap: Map<any, AnimationPlayer[]>, preStylesMap: Map<any, ɵStyleData>,\n      postStylesMap: Map<any, ɵStyleData>): AnimationPlayer {\n    const /** @type {?} */ triggerName = instruction.triggerName;\n    const /** @type {?} */ rootElement = instruction.element;\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    const /** @type {?} */ allQueriedPlayers: TransitionAnimationPlayer[] = [];\n    const /** @type {?} */ allConsumedElements = new Set<any>();\n    const /** @type {?} */ allSubElements = new Set<any>();\n    const /** @type {?} */ allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const /** @type {?} */ element = timelineInstruction.element;\n\n      // FIXME (matsko): make sure to-be-removed animations are removed properly\n      if (element['REMOVED']) return new NoopAnimationPlayer();\n\n      const /** @type {?} */ isQueriedElement = element !== rootElement;\n      let /** @type {?} */ previousPlayers: AnimationPlayer[] = EMPTY_PLAYER_ARRAY;\n      if (!allConsumedElements.has(element)) {\n        allConsumedElements.add(element);\n        const /** @type {?} */ _previousPlayers = allPreviousPlayersMap.get(element);\n        if (_previousPlayers) {\n          previousPlayers = _previousPlayers.map(p => p.getRealPlayer());\n        }\n      }\n      const /** @type {?} */ preStyles = preStylesMap.get(element);\n      const /** @type {?} */ postStyles = postStylesMap.get(element);\n      const /** @type {?} */ keyframes = normalizeKeyframes(\n          this._driver, this._normalizer, element, timelineInstruction.keyframes, preStyles,\n          postStyles);\n      const /** @type {?} */ player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n\n      // this means that this particular player belongs to a sub trigger. It is\n      // important that we match this player up with the corresponding (@trigger.listener)\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n\n      if (isQueriedElement) {\n        const /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n\n      return player;\n    });\n\n    allQueriedPlayers.forEach(player => {\n      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(\n          () => { deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player); });\n    });\n\n    allConsumedElements.forEach(element => { element.classList.add(NG_ANIMATING_CLASSNAME); });\n\n    const /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);\n    player.onDone(() => {\n      allConsumedElements.forEach(element => { element.classList.remove(NG_ANIMATING_CLASSNAME); });\n      setStyles(rootElement, instruction.toStyles);\n    });\n\n    // this basically makes all of the callbacks for sub element animations\n    // be dependent on the upper players for when they finish\n    allSubElements.forEach(\n        element => { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\n\n    return player;\n  }\n/**\n * @param {?} instruction\n * @param {?} keyframes\n * @param {?} previousPlayers\n * @return {?}\n */\nprivate _buildPlayer(\n      instruction: AnimationTimelineInstruction, keyframes: ɵStyleData[],\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    if (keyframes.length > 0) {\n      return this._driver.animate(\n          instruction.element, keyframes, instruction.duration, instruction.delay,\n          instruction.easing, previousPlayers);\n    }\n\n    // special case for when an empty transition|definition is provided\n    // ... there is no point in rendering an empty animation\n    return new NoopAnimationPlayer();\n  }\n}\n\nfunction TransitionAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nTransitionAnimationEngine.prototype.players;\n/** @type {?} */\nTransitionAnimationEngine.prototype.queuedRemovals;\n/** @type {?} */\nTransitionAnimationEngine.prototype.newlyInserted;\n/** @type {?} */\nTransitionAnimationEngine.prototype.newHostElements;\n/** @type {?} */\nTransitionAnimationEngine.prototype.playersByElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.playersByQueriedElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.statesByElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.totalAnimations;\n/** @type {?} */\nTransitionAnimationEngine.prototype.totalQueuedPlayers;\n/** @type {?} */\nTransitionAnimationEngine.prototype._namespaceLookup;\n/** @type {?} */\nTransitionAnimationEngine.prototype._namespaceList;\n/** @type {?} */\nTransitionAnimationEngine.prototype._flushFns;\n/** @type {?} */\nTransitionAnimationEngine.prototype._whenQuietFns;\n/** @type {?} */\nTransitionAnimationEngine.prototype.namespacesByHostElement;\n/** @type {?} */\nTransitionAnimationEngine.prototype.onRemovalComplete;\n/** @type {?} */\nTransitionAnimationEngine.prototype._driver;\n/** @type {?} */\nTransitionAnimationEngine.prototype._normalizer;\n}\n\nexport class TransitionAnimationPlayer implements AnimationPlayer {\nprivate _player: AnimationPlayer = new NoopAnimationPlayer();\nprivate _containsRealPlayer = false;\nprivate _queuedCallbacks: {[name: string]: (() => any)[]} = {};\nprivate _destroyed = false;\npublic parentPlayer: AnimationPlayer;\npublic markedForDestroy: boolean = false;\n/**\n * @param {?} namespaceId\n * @param {?} triggerName\n * @param {?} element\n */\nconstructor(public namespaceId: string,\npublic triggerName: string,\npublic element: any) {}\n/**\n * @return {?}\n */\nget queued() { return this._containsRealPlayer == false; }\n/**\n * @return {?}\n */\nget destroyed() { return this._destroyed; }\n/**\n * @param {?} player\n * @return {?}\n */\nsetRealPlayer(player: AnimationPlayer) {\n    if (this._containsRealPlayer) return;\n\n    this._player = player;\n    Object.keys(this._queuedCallbacks).forEach(phase => {\n      this._queuedCallbacks[phase].forEach(\n          callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks = {};\n    this._containsRealPlayer = true;\n  }\n/**\n * @return {?}\n */\ngetRealPlayer() { return this._player; }\n/**\n * @param {?} name\n * @param {?} callback\n * @return {?}\n */\nprivate _queueEvent(name: string, callback: (event: any) => any): void {\n    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n/**\n * @return {?}\n */\ninit(): void { this._player.init(); }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this.queued ? false : this._player.hasStarted(); }\n/**\n * @return {?}\n */\nplay(): void { !this.queued && this._player.play(); }\n/**\n * @return {?}\n */\npause(): void { !this.queued && this._player.pause(); }\n/**\n * @return {?}\n */\nrestart(): void { !this.queued && this._player.restart(); }\n/**\n * @return {?}\n */\nfinish(): void { this._player.finish(); }\n/**\n * @return {?}\n */\ndestroy(): void {\n    this._destroyed = true;\n    this._player.destroy();\n  }\n/**\n * @return {?}\n */\nreset(): void { !this.queued && this._player.reset(); }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: any): void {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n/**\n * @return {?}\n */\ngetPosition(): number { return this.queued ? 0 : this._player.getPosition(); }\n/**\n * @return {?}\n */\nget totalTime(): number { return this._player.totalTime; }\n}\n\nfunction TransitionAnimationPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nTransitionAnimationPlayer.prototype._player;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._containsRealPlayer;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._queuedCallbacks;\n/** @type {?} */\nTransitionAnimationPlayer.prototype._destroyed;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.parentPlayer;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.markedForDestroy;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.namespaceId;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.triggerName;\n/** @type {?} */\nTransitionAnimationPlayer.prototype.element;\n}\n\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} value\n * @return {?}\n */\nfunction deleteOrUnsetInMap(map: Map<any, any[]>| {[key: string]: any}, key: any, value: any) {\n  let /** @type {?} */ currentValues: any[]|null|undefined;\n  if (map instanceof Map) {\n    currentValues = map.get(key);\n    if (currentValues) {\n      if (currentValues.length) {\n        const /** @type {?} */ index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        map.delete(key);\n      }\n    }\n  } else {\n    currentValues = map[key];\n    if (currentValues) {\n      if (currentValues.length) {\n        const /** @type {?} */ index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        delete map[key];\n      }\n    }\n  }\n  return currentValues;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction normalizeTriggerValue(value: any): string {\n  switch (typeof value) {\n    case 'boolean':\n      return value ? '1' : '0';\n    default:\n      return value ? value.toString() : null;\n  }\n}\n/**\n * @param {?} node\n * @return {?}\n */\nfunction isElementNode(node: any) {\n  return node && node['nodeType'] === 1;\n}\n/**\n * @param {?} eventName\n * @return {?}\n */\nfunction isTriggerEventValid(eventName: string): boolean {\n  return eventName == 'start' || eventName == 'done';\n}\n/**\n * @param {?} element\n * @param {?=} value\n * @return {?}\n */\nfunction cloakElement(element: any, value?: string) {\n  const /** @type {?} */ oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\n\nlet /** @type {?} */ elementMatches: (element: any, selector: string) => boolean =\n    (element: any, selector: string) => false;\nif (typeof Element == 'function') {\n  if (Element.prototype.matches) {\n    elementMatches = (element: any, selector: string) => element.matches(selector);\n  } else {\n    const /** @type {?} */ proto = /** @type {?} */(( Element.prototype as any));\n    const /** @type {?} */ fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n        proto.oMatchesSelector || proto.webkitMatchesSelector;\n    elementMatches = (element: any, selector: string) => fn.apply(element, [selector]);\n  }\n}\n/**\n * @param {?} rootElement\n * @param {?} selector\n * @return {?}\n */\nfunction filterNodeClasses(rootElement: any, selector: string): any[] {\n  const /** @type {?} */ rootElements: any[] = [];\n  let /** @type {?} */ cursor: any = rootElement;\n  let /** @type {?} */ nextCursor: any = {};\n  do {\n    nextCursor = cursor.querySelector(selector);\n    if (!nextCursor) {\n      cursor = cursor.parentElement;\n      if (!cursor) break;\n      nextCursor = cursor = cursor.nextElementSibling;\n    } else {\n      while (nextCursor && elementMatches(nextCursor, selector)) {\n        rootElements.push(nextCursor);\n        nextCursor = nextCursor.nextElementSibling;\n        if (nextCursor) {\n          cursor = nextCursor;\n        } else {\n          cursor = cursor.parentElement;\n          if (!cursor) break;\n          nextCursor = cursor = cursor.nextElementSibling;\n        }\n      }\n    }\n  } while (nextCursor && nextCursor !== rootElement);\n\n  return rootElements;\n}\n/**\n * @param {?} driver\n * @param {?} elements\n * @param {?} elementPropsMap\n * @param {?} defaultStyle\n * @return {?}\n */\nfunction cloakAndComputeStyles(\n    driver: AnimationDriver, elements: any[], elementPropsMap: Map<any, Set<string>>,\n    defaultStyle: string): Map<any, ɵStyleData> {\n  const /** @type {?} */ cloakVals = elements.map(element => cloakElement(element));\n  const /** @type {?} */ valuesMap = new Map<any, ɵStyleData>();\n\n  elementPropsMap.forEach((props: Set<string>, element: any) => {\n    const /** @type {?} */ styles: ɵStyleData = {};\n    props.forEach(prop => {\n      const /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n\n      // there is no easy way to detect this because a sub element could be removed\n      // by a parent animation element being detached.\n      if (!value || value.length == 0) {\n        element['REMOVED'] = true;\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n\n  elements.forEach((element, i) => cloakElement(element, cloakVals[i]));\n  return valuesMap;\n}\n/**\n * @param {?} list\n * @return {?}\n */\nfunction listToArray(list: any): any[] {\n  const /** @type {?} */ arr: any[] = [];\n  arr.push(...( /** @type {?} */((list as any[]))));\n  return arr;\n}\n/**\n * @param {?} allEnterNodes\n * @return {?}\n */\nfunction collectEnterElements(allEnterNodes: any[]) {\n  allEnterNodes.forEach(element => element.classList.add(POTENTIAL_ENTER_CLASSNAME));\n  const /** @type {?} */ enterNodes = filterNodeClasses(document.body, POTENTIAL_ENTER_SELECTOR);\n  enterNodes.forEach(element => element.classList.add(ENTER_CLASSNAME));\n  allEnterNodes.forEach(element => element.classList.remove(POTENTIAL_ENTER_CLASSNAME));\n  return enterNodes;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimateTimings, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {copyObj, copyStyles, interpolateLocals, iteratorToArray, resolveTiming, resolveTimingValue} from '../util';\n\nimport {AnimateAst, AnimateChildAst, AnimateRefAst, Ast, AstVisitor, DynamicTimingAst, GroupAst, KeyframesAst, QueryAst, ReferenceAst, SequenceAst, StaggerAst, StateAst, StyleAst, TimingAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\n\nconst /** @type {?} */ ONE_FRAME_IN_MILLISECONDS = 1;\n/**\n * @param {?} rootElement\n * @param {?} ast\n * @param {?=} startingStyles\n * @param {?=} finalStyles\n * @param {?=} locals\n * @param {?=} subInstructions\n * @param {?=} errors\n * @return {?}\n */\nexport function buildAnimationTimelines(\n    rootElement: any, ast: Ast, startingStyles: ɵStyleData = {}, finalStyles: ɵStyleData = {},\n    locals: {[name: string]: any}, subInstructions?: ElementInstructionMap,\n    errors: any[] = []): AnimationTimelineInstruction[] {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(\n      rootElement, ast, startingStyles, finalStyles, locals, subInstructions, errors);\n}\n\nexport declare type StyleAtTime = {\n  time: number; value: string | number;\n};\n\nconst /** @type {?} */ DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */(( <Ast>{}));\nexport class AnimationTimelineContext {\n  parentContext: AnimationTimelineContext|null = null;\n  currentTimeline: TimelineBuilder;\n  currentAnimateTimings: AnimateTimings|null = null;\n  previousNode: Ast = DEFAULT_NOOP_PREVIOUS_NODE;\n  subContextCount = 0;\n  locals: {[name: string]: any} = {};\n  currentQueryIndex: number = 0;\n  currentQueryTotal: number = 0;\n  currentStaggerTime: number = 0;\n/**\n * @param {?} element\n * @param {?} subInstructions\n * @param {?} errors\n * @param {?} timelines\n * @param {?=} initialTimeline\n */\nconstructor(\npublic element: any,\npublic subInstructions: ElementInstructionMap,\npublic errors: any[],\npublic timelines: TimelineBuilder[], initialTimeline?: TimelineBuilder) {\n    this.currentTimeline = initialTimeline || new TimelineBuilder(element, 0);\n    timelines.push(this.currentTimeline);\n  }\n/**\n * @param {?} newLocals\n * @param {?=} skipIfExists\n * @return {?}\n */\nupdateLocals(newLocals: {[name: string]: any}|null, skipIfExists?: boolean) {\n    if (!newLocals) return;\n\n    Object.keys(newLocals).forEach(name => {\n      const /** @type {?} */ value = newLocals[name];\n      if (!skipIfExists || !newLocals.hasOwnProperty(name)) {\n        this.locals[name] = value;\n      }\n    });\n\n    if (newLocals.hasOwnProperty('duration')) {\n      this.locals['duration'] = resolveTimingValue(newLocals['duration']);\n    }\n\n    if (newLocals.hasOwnProperty('delay')) {\n      this.locals['delay'] = resolveTimingValue(newLocals['delay']);\n    }\n  }\n/**\n * @return {?}\n */\nprivate _copyLocals() {\n    const /** @type {?} */ locals: {[name: string]: any} = {};\n    if (this.locals) {\n      Object.keys(this.locals).forEach(name => {\n        if (name.charAt(0) == '$') {\n          locals[name] = this.locals[name];\n        }\n      });\n    }\n    return locals;\n  }\n/**\n * @param {?=} locals\n * @param {?=} element\n * @param {?=} newTime\n * @return {?}\n */\ncreateSubContext(locals: {[name: string]: any}|null = null, element?: any, newTime?: number):\n      AnimationTimelineContext {\n    const /** @type {?} */ target = element || this.element;\n    const /** @type {?} */ context = new AnimationTimelineContext(\n        target, this.subInstructions, this.errors, this.timelines,\n        this.currentTimeline.fork(target, newTime || 0));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n\n    context.locals = this._copyLocals();\n    context.updateLocals(locals);\n\n    context.currentQueryIndex = this.currentQueryIndex;\n    context.currentQueryTotal = this.currentQueryTotal;\n    context.parentContext = this;\n    this.subContextCount++;\n    return context;\n  }\n/**\n * @param {?=} newTime\n * @return {?}\n */\ntransformIntoNewTimeline(newTime?: number) {\n    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    this.currentTimeline = this.currentTimeline.fork(this.element, newTime || 0);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n/**\n * @param {?} instruction\n * @param {?} timings\n * @return {?}\n */\nappendInstructionToTimeline(instruction: AnimationTimelineInstruction, timings: AnimateTimings):\n      AnimateTimings {\n    const /** @type {?} */ updatedTimings: AnimateTimings = {\n      duration: timings.duration != null ? timings.duration : instruction.duration,\n      delay: this.currentTimeline.currentTime + (timings.delay != null ? timings.delay : 0) +\n          instruction.delay,\n      easing: timings.easing != null ? timings.easing : instruction.easing\n    };\n    const /** @type {?} */ builder = new SubTimelineBuilder(\n        instruction.element, instruction.keyframes, instruction.preStyleProps,\n        instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n    this.timelines.push(builder);\n    return updatedTimings;\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nincrementTime(time: number) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n/**\n * @param {?} delay\n * @return {?}\n */\ndelayNextStep(delay: number) {\n    // negative delays are not yet supported\n    if (delay > 0) {\n      this.currentTimeline.delayNextStep(delay);\n    }\n  }\n}\n\nfunction AnimationTimelineContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTimelineContext.prototype.parentContext;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentTimeline;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationTimelineContext.prototype.previousNode;\n/** @type {?} */\nAnimationTimelineContext.prototype.subContextCount;\n/** @type {?} */\nAnimationTimelineContext.prototype.locals;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentQueryIndex;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentQueryTotal;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentStaggerTime;\n/** @type {?} */\nAnimationTimelineContext.prototype.element;\n/** @type {?} */\nAnimationTimelineContext.prototype.subInstructions;\n/** @type {?} */\nAnimationTimelineContext.prototype.errors;\n/** @type {?} */\nAnimationTimelineContext.prototype.timelines;\n}\n\nexport class AnimationTimelineBuilderVisitor implements AstVisitor {\n/**\n * @param {?} rootElement\n * @param {?} ast\n * @param {?} startingStyles\n * @param {?} finalStyles\n * @param {?} locals\n * @param {?=} subInstructions\n * @param {?=} errors\n * @return {?}\n */\nbuildKeyframes(\n      rootElement: any, ast: Ast, startingStyles: ɵStyleData, finalStyles: ɵStyleData,\n      locals: {[name: string]: any}, subInstructions?: ElementInstructionMap,\n      errors: any[] = []): AnimationTimelineInstruction[] {\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const /** @type {?} */ context = new AnimationTimelineContext(rootElement, subInstructions, errors, []);\n    context.locals = locals || {};\n    context.currentTimeline.setStyles([startingStyles], null, context.errors, locals);\n\n    ast.visit(this, context);\n\n    // this checks to see if an actual animation happened\n    const /** @type {?} */ timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n    if (timelines.length && Object.keys(finalStyles).length) {\n      const /** @type {?} */ tl = timelines[timelines.length - 1];\n      if (!tl.allowOnlyTimelineStyles()) {\n        tl.setStyles([finalStyles], null, context.errors, locals);\n      }\n    }\n\n    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) :\n                              [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTrigger(ast: TriggerAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: StateAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: TransitionAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimateChild(ast: AnimateChildAst, context: AnimationTimelineContext): any {\n    const /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);\n    if (elementInstructions) {\n      const /** @type {?} */ innerContext = context.createSubContext(ast.locals);\n      const /** @type {?} */ startTime = context.currentTimeline.currentTime;\n      const /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext);\n      if (startTime != endTime) {\n        // we do this on the upper context because we created a sub context for\n        // the sub child animations\n        context.transformIntoNewTimeline(endTime);\n      }\n    }\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimateRef(ast: AnimateRefAst, context: AnimationTimelineContext): any {\n    const /** @type {?} */ innerContext = context.createSubContext(ast.locals);\n    innerContext.transformIntoNewTimeline();\n    this.visitReference(ast.animation, innerContext);\n    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} instructions\n * @param {?} context\n * @return {?}\n */\nprivate _visitSubInstructions(\n      instructions: AnimationTimelineInstruction[], context: AnimationTimelineContext): number {\n    const /** @type {?} */ locals = context.locals || {};\n    const /** @type {?} */ startTime = context.currentTimeline.currentTime;\n    let /** @type {?} */ furthestTime = startTime;\n\n    // this is a special-case for when a user wants to skip a sub\n    // animation from being fired entirely.\n    const /** @type {?} */ duration = /** @type {?} */(( locals['duration'] as number));\n    if (duration !== 0) {\n      const /** @type {?} */ timings: AnimateTimings = {duration, delay: locals['delay'], easing: locals['easing']};\n\n      instructions.forEach(instruction => {\n        const /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, timings);\n        furthestTime =\n            Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n      });\n    }\n\n    return furthestTime;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitReference(ast: ReferenceAst, context: AnimationTimelineContext) {\n    context.updateLocals(ast.locals, true);\n    ast.animation.visit(this, context);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: SequenceAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ subContextCount = context.subContextCount;\n    if (ast.locals) {\n      context.createSubContext(ast.locals);\n      context.transformIntoNewTimeline();\n\n      if (ast.locals.hasOwnProperty('delay')) {\n        if (context.previousNode instanceof StyleAst) {\n          context.currentTimeline.snapshotCurrentStyles();\n          context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n\n        context.delayNextStep( /** @type {?} */((ast.locals['delay'] as number)));\n      }\n    }\n\n    ast.steps.forEach(s => s.visit(this, context));\n\n    // this means that some animation function within the sequence\n    // ended up creating a sub timeline (which means the current\n    // timeline cannot overlap with the contents of the sequence)\n    if (context.subContextCount > subContextCount) {\n      context.transformIntoNewTimeline();\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: GroupAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ innerTimelines: TimelineBuilder[] = [];\n    let /** @type {?} */ furthestTime = context.currentTimeline.currentTime;\n    const /** @type {?} */ hasDelay = ast.locals && ast.locals.hasOwnProperty('delay');\n\n    ast.steps.forEach(s => {\n      const /** @type {?} */ innerContext = context.createSubContext(ast.locals);\n      if (hasDelay) {\n        innerContext.delayNextStep( /** @type {?} */((innerContext.locals['delay'] as number)));\n      }\n\n      s.visit(this, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTiming(ast: TimingAst, context: AnimationTimelineContext): AnimateTimings {\n    if (ast instanceof DynamicTimingAst) {\n      const /** @type {?} */ strValue = context.locals ?\n          interpolateLocals(ast.value, context.locals, context.errors) :\n          ast.value.toString();\n      return resolveTiming(strValue, context.errors);\n    } else {\n      return {duration: ast.duration, delay: ast.delay, easing: ast.easing};\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: AnimateAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ timings = context.currentAnimateTimings = this.visitTiming(ast.timings, context);\n    const /** @type {?} */ timeline = context.currentTimeline;\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      timeline.snapshotCurrentStyles();\n    }\n\n    const /** @type {?} */ style = ast.style;\n    if (style instanceof KeyframesAst) {\n      this.visitKeyframes(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle( /** @type {?} */((style as StyleAst)), context);\n      timeline.applyStylesToKeyframe();\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: StyleAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ timeline = context.currentTimeline;\n    const /** @type {?} */ timings = /** @type {?} */(( context.currentAnimateTimings));\n\n    // this is a special case for when a style() call\n    // directly follows  an animate() call (but not inside of an animate() call)\n    if (!timings && timeline.getCurrentStyleProperties().length) {\n      timeline.forwardFrame();\n    }\n\n    const /** @type {?} */ easing = (timings && timings.easing) || ast.easing;\n    if (ast.isEmptyStep) {\n      timeline.applyEmptyStep(easing);\n    } else {\n      timeline.setStyles(ast.styles, easing, context.errors, context.locals);\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframes(ast: KeyframesAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ currentAnimateTimings = /** @type {?} */(( context.currentAnimateTimings));\n    const /** @type {?} */ startTime = ( /** @type {?} */((context.currentTimeline))).duration;\n    const /** @type {?} */ duration = currentAnimateTimings.duration;\n    const /** @type {?} */ innerContext = context.createSubContext();\n    const /** @type {?} */ innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = currentAnimateTimings.easing;\n\n    ast.styles.forEach(step => {\n      innerTimeline.forwardTime(step.offset * duration);\n      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.locals);\n      innerTimeline.applyStylesToKeyframe();\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child even if the new timeline below is not used\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitQuery(ast: QueryAst, context: AnimationTimelineContext) {\n    // in the event that the first step before this is a style step we need\n    // to ensure the styles are applied before the children are animated\n    const /** @type {?} */ startTime = context.currentTimeline.currentTime;\n    const /** @type {?} */ locals = ast.locals || {};\n    const /** @type {?} */ delayVal = locals.hasOwnProperty('delay') ? /** @type {?} */(( locals['delay'] as number)) : 0;\n\n    if (delayVal &&\n        (context.previousNode instanceof StyleAst ||\n         (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n\n    let /** @type {?} */ furthestTime = startTime;\n    const /** @type {?} */ elms = invokeQuery(\n        context.element, ast.selector, ast.originalSelector, ast.multi, ast.includeSelf,\n        locals['optional'] ? true : false, context.errors);\n\n    context.currentQueryTotal = elms.length;\n    let /** @type {?} */ sameElementTimeline: TimelineBuilder|null = null;\n    elms.forEach((element, i) => {\n\n      context.currentQueryIndex = i;\n      const /** @type {?} */ innerContext = context.createSubContext(ast.locals, element);\n      if (delayVal) {\n        innerContext.delayNextStep(delayVal);\n      }\n\n      if (element === context.element) {\n        sameElementTimeline = innerContext.currentTimeline;\n      }\n\n      ast.animation.visit(this, innerContext);\n\n      const /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;\n      furthestTime = Math.max(furthestTime, endTime);\n    });\n\n    context.currentQueryIndex = 0;\n    context.currentQueryTotal = 0;\n    context.transformIntoNewTimeline(furthestTime);\n\n    if (sameElementTimeline) {\n      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStagger(ast: StaggerAst, context: AnimationTimelineContext) {\n    const /** @type {?} */ parentContext = /** @type {?} */(( context.parentContext));\n    const /** @type {?} */ tl = context.currentTimeline;\n    const /** @type {?} */ timings = ast.timings;\n    const /** @type {?} */ duration = Math.abs(timings.duration);\n    const /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);\n    let /** @type {?} */ delay = duration * context.currentQueryIndex;\n\n    let /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n    switch (staggerTransformer) {\n      case 'reverse':\n        delay = maxTime - delay;\n        break;\n      case 'full':\n        delay = parentContext.currentStaggerTime;\n        break;\n    }\n\n    if (delay) {\n      context.currentTimeline.delayNextStep(delay);\n    }\n\n    const /** @type {?} */ startingTime = context.currentTimeline.currentTime;\n    ast.animation.visit(this, context);\n    context.previousNode = ast;\n\n    // time = duration + delay\n    // the reason why this computation is so complex is because\n    // the inner timeline may either have a delay value or a stretched\n    // keyframe depending on if a subtimeline is not used or is used.\n    parentContext.currentStaggerTime =\n        (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\n  }\n}\nexport class TimelineBuilder {\npublic duration: number = 0;\npublic easing: string|null;\nprivate _previousKeyframe: ɵStyleData = {};\nprivate _currentKeyframe: ɵStyleData = {};\nprivate _keyframes = new Map<number, ɵStyleData>();\nprivate _styleSummary: {[prop: string]: StyleAtTime} = {};\nprivate _localTimelineStyles: ɵStyleData;\nprivate _globalTimelineStyles: ɵStyleData;\nprivate _pendingStyles: ɵStyleData = {};\nprivate _backFill: ɵStyleData = {};\nprivate _currentEmptyStepKeyframe: ɵStyleData|null = null;\nprivate _allowEmptyAnimation = false;\n/**\n * @param {?} element\n * @param {?} startTime\n * @param {?=} _elementTimelineStylesLookup\n * @param {?=} _globalTimelineMap\n */\nconstructor(\npublic element: any,\npublic startTime: number,\nprivate _elementTimelineStylesLookup?: Map<any, ɵStyleData>,\nprivate _globalTimelineMap?: Map<any, TimelineBuilder>) {\n    if (!this._elementTimelineStylesLookup) {\n      this._elementTimelineStylesLookup = new Map<any, ɵStyleData>();\n    }\n\n    if (this._globalTimelineMap) {\n      // this is a special case for queries that solely assign styles\n      // without any animation arcs in between. When this occurs we want\n      // to ensure those styles are visually placed on screen, but we do\n      // not want to continue the timeline since there may be too many styles\n      // to build up for this new timeline. Therefore we just make sure that\n      // the styles are placed in the previous timeline and continue along as normal\n      const existingBuilder = this._globalTimelineMap.get(element);\n      if (existingBuilder && existingBuilder.containsOnlyPendingStyles()) {\n        existingBuilder.applyStylesToKeyframe();\n        existingBuilder._allowEmptyAnimation = true;\n      }\n    } else {\n      this._globalTimelineMap = new Map<any, TimelineBuilder>();\n    }\n    this._globalTimelineMap.set(element, this);\n\n    this._localTimelineStyles = Object.create(this._backFill, {});\n    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element) !;\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n    }\n    this._loadKeyframe();\n  }\n/**\n * @return {?}\n */\ncontainsAnimation(): boolean {\n    switch (this._keyframes.size) {\n      case 0:\n        return false;\n      case 1:\n        return this._allowEmptyAnimation;\n      default:\n        return true;\n    }\n  }\n/**\n * @return {?}\n */\ncontainsOnlyPendingStyles(): boolean {\n    return this._keyframes.size === 1 && Object.keys(this._pendingStyles).length > 0;\n  }\n/**\n * @return {?}\n */\ngetCurrentStyleProperties(): string[] { return Object.keys(this._currentKeyframe); }\n/**\n * @return {?}\n */\nget currentTime() { return this.startTime + this.duration; }\n/**\n * @param {?} delay\n * @return {?}\n */\ndelayNextStep(delay: number) {\n    if (this.duration == 0) {\n      this.startTime += delay;\n    } else {\n      this.forwardTime(this.currentTime + delay);\n    }\n  }\n/**\n * @param {?} element\n * @param {?=} currentTime\n * @return {?}\n */\nfork(element: any, currentTime = 0): TimelineBuilder {\n    this.applyStylesToKeyframe();\n    return new TimelineBuilder(\n        element, currentTime || this.currentTime, this._elementTimelineStylesLookup,\n        this._globalTimelineMap);\n  }\n/**\n * @return {?}\n */\nprivate _loadKeyframe() {\n    if (this._currentKeyframe) {\n      this._previousKeyframe = this._currentKeyframe;\n    }\n    this._currentKeyframe = /** @type {?} */(( this._keyframes.get(this.duration)));\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = Object.create(this._backFill, {});\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n/**\n * @return {?}\n */\nforwardFrame() {\n    this.duration += ONE_FRAME_IN_MILLISECONDS;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nforwardTime(time: number) {\n    this.applyStylesToKeyframe();\n    this.duration = time;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} prop\n * @param {?} value\n * @return {?}\n */\nprivate _updateStyle(prop: string, value: string|number) {\n    this._localTimelineStyles[prop] = value;\n    this._globalTimelineStyles[prop] = value;\n    this._styleSummary[prop] = {time: this.currentTime, value};\n  }\n/**\n * @return {?}\n */\nallowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe; }\n/**\n * @param {?} easing\n * @return {?}\n */\napplyEmptyStep(easing: string|null) {\n    if (easing) {\n      this._previousKeyframe['easing'] = easing;\n    }\n\n    // special case for animate(duration):\n    // all missing styles are filled with a `*` value then\n    // if any destination styles are filled in later on the same\n    // keyframe then they will override the overridden styles\n    // We use `_globalTimelineStyles` here because there may be\n    // styles in previous keyframes that are not present in this timeline\n    Object.keys(this._globalTimelineStyles).forEach(prop => {\n      this._backFill[prop] = this._globalTimelineStyles[prop] || AUTO_STYLE;\n      this._currentKeyframe[prop] = AUTO_STYLE;\n    });\n    this._currentEmptyStepKeyframe = this._currentKeyframe;\n  }\n/**\n * @param {?} input\n * @param {?} easing\n * @param {?} errors\n * @param {?=} locals\n * @return {?}\n */\nsetStyles(\n      input: (ɵStyleData|string)[], easing: string|null, errors: any[],\n      locals?: {[name: string]: any}) {\n    if (easing) {\n      this._previousKeyframe['easing'] = easing;\n    }\n\n    const /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);\n    Object.keys(styles).forEach(prop => {\n      let /** @type {?} */ val = styles[prop];\n      if (locals) {\n        val = interpolateLocals(styles[prop], locals, errors);\n      }\n      this._pendingStyles[prop] = val;\n      if (!this._localTimelineStyles.hasOwnProperty(prop)) {\n        this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ?\n            this._globalTimelineStyles[prop] :\n            AUTO_STYLE;\n      }\n      this._updateStyle(prop, val);\n    });\n  }\n/**\n * @return {?}\n */\napplyStylesToKeyframe() {\n    const /** @type {?} */ styles = this._pendingStyles;\n    const /** @type {?} */ props = Object.keys(styles);\n    if (props.length == 0) return;\n\n    this._pendingStyles = {};\n\n    props.forEach(prop => {\n      const /** @type {?} */ val = styles[prop];\n      this._currentKeyframe[prop] = val;\n    });\n\n    Object.keys(this._localTimelineStyles).forEach(prop => {\n      if (!this._currentKeyframe.hasOwnProperty(prop)) {\n        this._currentKeyframe[prop] = this._localTimelineStyles[prop];\n      }\n    });\n  }\n/**\n * @return {?}\n */\nsnapshotCurrentStyles() { copyStyles(this._localTimelineStyles, false, this._currentKeyframe); }\n/**\n * @return {?}\n */\ngetFinalKeyframe() { return this._keyframes.get(this.duration); }\n/**\n * @return {?}\n */\nget properties() {\n    const /** @type {?} */ properties: string[] = [];\n    for (let /** @type {?} */ prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n/**\n * @param {?} timeline\n * @return {?}\n */\nmergeTimelineCollectedStyles(timeline: TimelineBuilder) {\n    Object.keys(timeline._styleSummary).forEach(prop => {\n      const /** @type {?} */ details0 = this._styleSummary[prop];\n      const /** @type {?} */ details1 = timeline._styleSummary[prop];\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    this.applyStylesToKeyframe();\n    const /** @type {?} */ preStyleProps = new Set<string>();\n    const /** @type {?} */ postStyleProps = new Set<string>();\n    const /** @type {?} */ isEmpty = this._allowEmptyAnimation && this.duration === 0;\n\n    let /** @type {?} */ finalKeyframes: ɵStyleData[] = [];\n    this._keyframes.forEach((keyframe, time) => {\n      const /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);\n      Object.keys(finalKeyframe).forEach(prop => {\n        const /** @type {?} */ value = finalKeyframe[prop];\n        if (value == PRE_STYLE) {\n          preStyleProps.add(prop);\n        } else if (value == AUTO_STYLE) {\n          postStyleProps.add(prop);\n        }\n      });\n      if (!isEmpty) {\n        finalKeyframe['offset'] = time / this.duration;\n      }\n      finalKeyframes.push(finalKeyframe);\n    });\n\n    const /** @type {?} */ preProps: string[] = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\n    const /** @type {?} */ postProps: string[] = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\n\n    // special case for a 0-second animation (which is designed just to place styles onscreen)\n    if (isEmpty) {\n      const /** @type {?} */ kf0 = finalKeyframes[0];\n      const /** @type {?} */ kf1 = copyObj(kf0);\n      kf0['offset'] = 0;\n      kf1['offset'] = 1;\n      finalKeyframes = [kf0, kf1];\n    }\n\n    return createTimelineInstruction(\n        this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime,\n        this.easing, false);\n  }\n}\n\nfunction TimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineBuilder.prototype.duration;\n/** @type {?} */\nTimelineBuilder.prototype.easing;\n/** @type {?} */\nTimelineBuilder.prototype._previousKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._currentKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._keyframes;\n/** @type {?} */\nTimelineBuilder.prototype._styleSummary;\n/** @type {?} */\nTimelineBuilder.prototype._localTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._globalTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._pendingStyles;\n/** @type {?} */\nTimelineBuilder.prototype._backFill;\n/** @type {?} */\nTimelineBuilder.prototype._currentEmptyStepKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._allowEmptyAnimation;\n/** @type {?} */\nTimelineBuilder.prototype.element;\n/** @type {?} */\nTimelineBuilder.prototype.startTime;\n/** @type {?} */\nTimelineBuilder.prototype._elementTimelineStylesLookup;\n/** @type {?} */\nTimelineBuilder.prototype._globalTimelineMap;\n}\n\nclass SubTimelineBuilder extends TimelineBuilder {\npublic timings: AnimateTimings;\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} timings\n * @param {?=} _stretchStartingKeyframe\n */\nconstructor(\npublic element: any,\npublic keyframes: ɵStyleData[],\npublic preStyleProps: string[],\npublic postStyleProps: string[], timings: AnimateTimings,\nprivate _stretchStartingKeyframe: boolean = false) {\n    super(element, timings.delay);\n    this.timings = {duration: timings.duration, delay: timings.delay, easing: timings.easing};\n  }\n/**\n * @return {?}\n */\ncontainsAnimation(): boolean { return this.keyframes.length > 1; }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    let /** @type {?} */ keyframes = this.keyframes;\n    let {delay, duration, easing} = this.timings;\n    if (this._stretchStartingKeyframe && delay) {\n      const /** @type {?} */ newKeyframes: ɵStyleData[] = [];\n      const /** @type {?} */ totalTime = duration + delay;\n      const /** @type {?} */ startingGap = delay / totalTime;\n\n      // the original starting keyframe now starts once the delay is done\n      const /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);\n      newFirstKeyframe['offset'] = 0;\n      newKeyframes.push(newFirstKeyframe);\n\n      const /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);\n      oldFirstKeyframe['offset'] = roundOffset(startingGap);\n      newKeyframes.push(oldFirstKeyframe);\n\n      /*\n        When the keyframe is stretched then it means that the delay before the animation\n        starts is gone. Instead the first keyframe is placed at the start of the animation\n        and it is then copied to where it starts when the original delay is over. This basically\n        means nothing animates during that delay, but the styles are still renderered. For this\n        to work the original offset values that exist in the original keyframes must be \"warped\"\n        so that they can take the new keyframe + delay into account.\n\n        delay=1000, duration=1000, keyframes = 0 .5 1\n\n        turns into\n\n        delay=0, duration=2000, keyframes = 0 .33 .66 1\n       */\n\n      // offsets between 1 ... n -1 are all warped by the keyframe stretch\n      const /** @type {?} */ limit = keyframes.length - 1;\n      for (let /** @type {?} */ i = 1; i <= limit; i++) {\n        let /** @type {?} */ kf = copyStyles(keyframes[i], false);\n        const /** @type {?} */ oldOffset = /** @type {?} */(( kf['offset'] as number));\n        const /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;\n        kf['offset'] = roundOffset(timeAtKeyframe / totalTime);\n        newKeyframes.push(kf);\n      }\n\n      // the new starting keyframe should be added at the start\n      duration = totalTime;\n      delay = 0;\n      easing = '';\n\n      keyframes = newKeyframes;\n    }\n\n    return createTimelineInstruction(\n        this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing,\n        true);\n  }\n}\n\nfunction SubTimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nSubTimelineBuilder.prototype.timings;\n/** @type {?} */\nSubTimelineBuilder.prototype.element;\n/** @type {?} */\nSubTimelineBuilder.prototype.keyframes;\n/** @type {?} */\nSubTimelineBuilder.prototype.preStyleProps;\n/** @type {?} */\nSubTimelineBuilder.prototype.postStyleProps;\n/** @type {?} */\nSubTimelineBuilder.prototype._stretchStartingKeyframe;\n}\n\n/**\n * @param {?} rootElement\n * @param {?} selector\n * @param {?} originalSelector\n * @param {?} multi\n * @param {?} includeSelf\n * @param {?} optional\n * @param {?} errors\n * @return {?}\n */\nfunction invokeQuery(\n    rootElement: any, selector: string, originalSelector: string, multi: boolean,\n    includeSelf: boolean, optional: boolean, errors: any[]): any[] {\n  let /** @type {?} */ results: any[] = [];\n  if (includeSelf) {\n    results.push(rootElement);\n  }\n  if (multi) {\n    results.push(...rootElement.querySelectorAll(selector));\n  } else if (results.length == 0) {\n    const /** @type {?} */ elm = rootElement.querySelector(selector);\n    if (elm) {\n      results.push(elm);\n    }\n  }\n  if (!optional && results.length == 0) {\n    const /** @type {?} */ fn = multi ? 'queryAll' : 'query';\n    errors.push(\n        `\\`${fn}(\"${originalSelector}\")\\` returned zero elements. (Use \\`${fn}(\"${originalSelector}\", { optional: true })\\` if you wish to allow this.)`);\n  }\n  return results;\n}\n/**\n * @param {?} offset\n * @param {?=} decimalPoints\n * @return {?}\n */\nfunction roundOffset(offset: number, decimalPoints = 3): number {\n  const /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);\n  return Math.round(offset * mult) / mult;\n}\n/**\n * @param {?} input\n * @param {?} allStyles\n * @return {?}\n */\nfunction flattenStyles(input: (ɵStyleData | string)[], allStyles: ɵStyleData) {\n  const /** @type {?} */ styles: ɵStyleData = {};\n  let /** @type {?} */ allProperties: string[];\n  input.forEach(token => {\n    if (token === '*') {\n      allProperties = allProperties || Object.keys(allStyles);\n      allProperties.forEach(prop => { styles[prop] = AUTO_STYLE; });\n    } else {\n      copyStyles( /** @type {?} */((token as ɵStyleData)), false, styles);\n    }\n  });\n  return styles;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, ɵStyleData} from '@angular/animations';\nimport {normalizeStyles} from '../util';\nimport {Ast} from './animation_ast';\nimport {buildAnimationAst} from './animation_ast_builder';\nimport {buildAnimationTimelines} from './animation_timeline_builder';\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\nexport class Animation {\nprivate _animationAst: Ast;\n/**\n * @param {?} input\n */\nconstructor(input: AnimationMetadata|AnimationMetadata[]) {\n    const errors: any[] = [];\n    const ast = buildAnimationAst(input, errors);\n    if (errors.length) {\n      const errorMessage = `animation validation failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n    this._animationAst = ast;\n  }\n/**\n * @param {?} element\n * @param {?} startingStyles\n * @param {?} destinationStyles\n * @param {?} locals\n * @param {?=} subInstructions\n * @return {?}\n */\nbuildTimelines(\n      element: any, startingStyles: ɵStyleData|ɵStyleData[],\n      destinationStyles: ɵStyleData|ɵStyleData[], locals: {[key: string]: any},\n      subInstructions?: ElementInstructionMap): AnimationTimelineInstruction[] {\n    const /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */((\n                                                  <ɵStyleData>startingStyles));\n    const /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */((\n                                                    <ɵStyleData>destinationStyles));\n    const /** @type {?} */ errors: any = [];\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const /** @type {?} */ result = buildAnimationTimelines(\n        element, this._animationAst, start, dest, locals, subInstructions, errors);\n    if (errors.length) {\n      const /** @type {?} */ errorMessage = `animation building failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n    return result;\n  }\n}\n\nfunction Animation_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimation.prototype._animationAst;\n}\n\n","\n/**\n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationStyleNormalizer {\n/**\n * @abstract\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]) {}\n/**\n * @abstract\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]) {}\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class NoopAnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string { return propertyName; }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    return /** @type {?} */(( <any>value));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationStyleNormalizer} from './animation_style_normalizer';\nexport class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n/**\n * @param {?} propertyName\n * @param {?} errors\n * @return {?}\n */\nnormalizePropertyName(propertyName: string, errors: string[]): string {\n    return dashCaseToCamelCase(propertyName);\n  }\n/**\n * @param {?} userProvidedProperty\n * @param {?} normalizedProperty\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nnormalizeStyleValue(\n      userProvidedProperty: string, normalizedProperty: string, value: string|number,\n      errors: string[]): string {\n    let /** @type {?} */ unit: string = '';\n    const /** @type {?} */ strVal = value.toString().trim();\n\n    if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {\n      if (typeof value === 'number') {\n        unit = 'px';\n      } else {\n        const /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);\n        }\n      }\n    }\n    return strVal + unit;\n  }\n}\n\nconst /** @type {?} */ DIMENSIONAL_PROP_MAP = makeBooleanMap(\n    'width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent'\n        .split(','));\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction makeBooleanMap(keys: string[]): {[key: string]: boolean} {\n  const /** @type {?} */ map: {[key: string]: boolean} = {};\n  keys.forEach(key => map[key] = true);\n  return map;\n}\n\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\n\nimport {getOrSetAsInMap} from '../render/shared';\nimport {iteratorToArray} from '../util';\n\nimport {TransitionAst} from './animation_ast';\nimport {buildAnimationTimelines} from './animation_timeline_builder';\nimport {TransitionMatcherFn} from './animation_transition_expr';\nimport {AnimationTransitionInstruction, createTransitionInstruction} from './animation_transition_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\nexport class AnimationTransitionFactory {\n/**\n * @param {?} _triggerName\n * @param {?} ast\n * @param {?} _stateStyles\n */\nconstructor(\nprivate _triggerName: string,\npublic ast: TransitionAst,\nprivate _stateStyles: {[stateName: string]: ɵStyleData}) {}\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatch(currentState: any, nextState: any): boolean {\n    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);\n  }\n/**\n * @param {?} element\n * @param {?} currentState\n * @param {?} nextState\n * @param {?=} locals\n * @param {?=} subInstructions\n * @return {?}\n */\nbuild(\n      element: any, currentState: any, nextState: any,\n      locals?: {[varName: string]: string | number},\n      subInstructions?: ElementInstructionMap): AnimationTransitionInstruction|undefined {\n    let /** @type {?} */ animationLocals: {[varName: string]: string | number} = {};\n    const /** @type {?} */ transitionLocals = this.ast.locals;\n    if (transitionLocals) {\n      animationLocals = /** @type {?} */(( (locals || {}) as{[varName: string]: string | number}));\n      Object.keys(this.ast.locals).forEach(prop => {\n        if (!animationLocals.hasOwnProperty(prop)) {\n          animationLocals[prop] = transitionLocals[prop];\n        }\n      });\n    }\n\n    const /** @type {?} */ backupStateStyles = this._stateStyles['*'] || {};\n    const /** @type {?} */ currentStateStyles = this._stateStyles[currentState] || backupStateStyles;\n    const /** @type {?} */ nextStateStyles = this._stateStyles[nextState] || backupStateStyles;\n\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ timelines = buildAnimationTimelines(\n        element, this.ast.animation, currentStateStyles, nextStateStyles, animationLocals,\n        subInstructions, errors);\n\n    if (errors.length) {\n      const /** @type {?} */ errorMessage = `animation building failed:\\n${errors.join(\"\\n\")}`;\n      throw new Error(errorMessage);\n    }\n\n    const /** @type {?} */ preStyleMap = new Map<any, {[prop: string]: boolean}>();\n    const /** @type {?} */ postStyleMap = new Map<any, {[prop: string]: boolean}>();\n    const /** @type {?} */ queriedElements = new Set<any>();\n    timelines.forEach(tl => {\n      const /** @type {?} */ elm = tl.element;\n      const /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});\n      tl.preStyleProps.forEach(prop => preProps[prop] = true);\n\n      const /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});\n      tl.postStyleProps.forEach(prop => postProps[prop] = true);\n\n      if (elm !== element) {\n        queriedElements.add(elm);\n      }\n    });\n\n    const /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());\n    return createTransitionInstruction(\n        element, this._triggerName, currentState, nextState, nextState === 'void',\n        currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap,\n        postStyleMap);\n  }\n}\n\nfunction AnimationTransitionFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTransitionFactory.prototype._triggerName;\n/** @type {?} */\nAnimationTransitionFactory.prototype.ast;\n/** @type {?} */\nAnimationTransitionFactory.prototype._stateStyles;\n}\n\n/**\n * @param {?} matchFns\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nfunction oneOrMoreTransitionsMatch(\n    matchFns: TransitionMatcherFn[], currentState: any, nextState: any): boolean {\n  return matchFns.some(fn => fn(currentState, nextState));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\n\nimport {copyStyles} from '../util';\n\nimport {SequenceAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationTransitionFactory} from './animation_transition_factory';\n/**\n * \\@experimental Animation support is experimental.\n * @param {?} name\n * @param {?} ast\n * @return {?}\n */\nexport function buildTrigger(name: string, ast: TriggerAst): AnimationTrigger {\n  return new AnimationTrigger(name, ast);\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class AnimationTrigger {\npublic transitionFactories: AnimationTransitionFactory[] = [];\npublic fallbackTransition: AnimationTransitionFactory;\npublic states: {[stateName: string]: ɵStyleData} = {};\n/**\n * @param {?} name\n * @param {?} ast\n */\nconstructor(public name: string,\npublic ast: TriggerAst) {\n    ast.states.forEach(ast => {\n      const obj = this.states[ast.name] = {};\n      ast.style.styles.forEach(styleTuple => {\n        if (typeof styleTuple == 'object') {\n          copyStyles(styleTuple as ɵStyleData, false, obj);\n        }\n      });\n    });\n\n    balanceProperties(this.states, 'true', '1');\n    balanceProperties(this.states, 'false', '0');\n\n    ast.transitions.forEach(ast => {\n      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));\n    });\n\n    this.fallbackTransition = createFallbackTransition(name, this.states);\n  }\n/**\n * @return {?}\n */\nget containsQueries() { return this.ast.queryCount > 0; }\n/**\n * @param {?} currentState\n * @param {?} nextState\n * @return {?}\n */\nmatchTransition(currentState: any, nextState: any): AnimationTransitionFactory|null {\n    const /** @type {?} */ entry = this.transitionFactories.find(f => f.match(currentState, nextState));\n    return entry || null;\n  }\n}\n\nfunction AnimationTrigger_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTrigger.prototype.transitionFactories;\n/** @type {?} */\nAnimationTrigger.prototype.fallbackTransition;\n/** @type {?} */\nAnimationTrigger.prototype.states;\n/** @type {?} */\nAnimationTrigger.prototype.name;\n/** @type {?} */\nAnimationTrigger.prototype.ast;\n}\n\n/**\n * @param {?} triggerName\n * @param {?} states\n * @return {?}\n */\nfunction createFallbackTransition(\n    triggerName: string, states: {[stateName: string]: ɵStyleData}): AnimationTransitionFactory {\n  const /** @type {?} */ matchers = [(fromState: any, toState: any) => true];\n  const /** @type {?} */ animation = new SequenceAst([]);\n  const /** @type {?} */ transition = new TransitionAst(matchers, animation);\n  return new AnimationTransitionFactory(triggerName, transition, states);\n}\n/**\n * @param {?} obj\n * @param {?} key1\n * @param {?} key2\n * @return {?}\n */\nfunction balanceProperties(obj: {[key: string]: any}, key1: string, key2: string) {\n  if (obj.hasOwnProperty(key1)) {\n    if (!obj.hasOwnProperty(key2)) {\n      obj[key2] = obj[key1];\n    }\n  } else if (obj.hasOwnProperty(key2)) {\n    obj[key1] = obj[key2];\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationMetadata, AnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {Ast} from '../dsl/animation_ast';\nimport {buildAnimationAst} from '../dsl/animation_ast_builder';\nimport {buildAnimationTimelines} from '../dsl/animation_timeline_builder';\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst /** @type {?} */ EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();\nexport class TimelineAnimationEngine {\nprivate _animations: {[id: string]: Ast} = {};\nprivate _playersById: {[id: string]: AnimationPlayer} = {};\npublic players: AnimationPlayer[] = [];\n/**\n * @param {?} _driver\n * @param {?} _normalizer\n */\nconstructor(private _driver: AnimationDriver,\nprivate _normalizer: AnimationStyleNormalizer) {}\n/**\n * @param {?} id\n * @param {?} metadata\n * @return {?}\n */\nregister(id: string, metadata: AnimationMetadata|AnimationMetadata[]) {\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = buildAnimationAst(metadata, errors);\n    if (errors.length) {\n      throw new Error(\n          `Unable to build the animation due to the following errors: ${errors.join(\"\\n\")}`);\n    } else {\n      this._animations[id] = ast;\n    }\n  }\n/**\n * @param {?} i\n * @param {?} preStyles\n * @param {?=} postStyles\n * @return {?}\n */\nprivate _buildPlayer(\n      i: AnimationTimelineInstruction, preStyles: ɵStyleData,\n      postStyles?: ɵStyleData): AnimationPlayer {\n    const /** @type {?} */ element = i.element;\n    const /** @type {?} */ keyframes = normalizeKeyframes(\n        this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);\n    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?=} locals\n * @return {?}\n */\ncreate(id: string, element: any, locals: {[key: string]: string | number} = {}): AnimationPlayer {\n    const /** @type {?} */ errors: any[] = [];\n    const /** @type {?} */ ast = this._animations[id];\n    let /** @type {?} */ instructions: AnimationTimelineInstruction[];\n\n    const /** @type {?} */ autoStylesMap = new Map<any, ɵStyleData>();\n\n    if (ast) {\n      instructions =\n          buildAnimationTimelines(element, ast, {}, {}, locals, EMPTY_INSTRUCTION_MAP, errors);\n      instructions.forEach(inst => {\n        const /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});\n        inst.postStyleProps.forEach(prop => styles[prop] = null);\n      });\n    } else {\n      errors.push('The requested animation doesn\\'t exist or has already been destroyed');\n      instructions = [];\n    }\n\n    if (errors.length) {\n      throw new Error(\n          `Unable to create the animation due to the following errors: ${errors.join(\"\\n\")}`);\n    }\n\n    autoStylesMap.forEach((styles, element) => {\n      Object.keys(styles).forEach(\n          prop => { styles[prop] = this._driver.computeStyle(element, prop, AUTO_STYLE); });\n    });\n\n    const /** @type {?} */ players = instructions.map(i => {\n      const /** @type {?} */ styles = autoStylesMap.get(i.element);\n      return this._buildPlayer(i, {}, styles);\n    });\n    const /** @type {?} */ player = optimizeGroupPlayer(players);\n    this._playersById[id] = player;\n    player.onDestroy(() => this.destroy(id));\n\n    this.players.push(player);\n    return player;\n  }\n/**\n * @param {?} id\n * @return {?}\n */\ndestroy(id: string) {\n    const /** @type {?} */ player = this._getPlayer(id);\n    player.destroy();\n    delete this._playersById[id];\n    const /** @type {?} */ index = this.players.indexOf(player);\n    if (index >= 0) {\n      this.players.splice(index, 1);\n    }\n  }\n/**\n * @param {?} id\n * @return {?}\n */\nprivate _getPlayer(id: string): AnimationPlayer {\n    const /** @type {?} */ player = this._playersById[id];\n    if (!player) {\n      throw new Error(`Unable to find the timeline player referenced by ${id}`);\n    }\n    return player;\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?} eventName\n * @param {?} callback\n * @return {?}\n */\nlisten(id: string, element: string, eventName: string, callback: (event: any) => any):\n      () => void {\n    // triggerName, fromState, toState are all ignored for timeline animations\n    const /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');\n    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n    return () => {};\n  }\n/**\n * @param {?} id\n * @param {?} element\n * @param {?} command\n * @param {?} args\n * @return {?}\n */\ncommand(id: string, element: any, command: string, args: any[]): void {\n    if (command == 'register') {\n      this.register(id, /** @type {?} */(( args[0] as AnimationMetadata | AnimationMetadata[])));\n      return;\n    }\n\n    if (command == 'create') {\n      const /** @type {?} */ locals = /** @type {?} */(( (args[0] || {}) as{[key: string]: string | number}));\n      this.create(id, element, locals);\n      return;\n    }\n\n    const /** @type {?} */ player = this._getPlayer(id);\n    switch (command) {\n      case 'play':\n        player.play();\n        break;\n      case 'pause':\n        player.pause();\n        break;\n      case 'reset':\n        player.reset();\n        break;\n      case 'restart':\n        player.restart();\n        break;\n      case 'finish':\n        player.finish();\n        break;\n      case 'init':\n        player.init();\n        break;\n      case 'setPosition':\n        player.setPosition(parseFloat( /** @type {?} */((args[0] as string))));\n        break;\n      case 'destroy':\n        this.destroy(id);\n        break;\n    }\n  }\n}\n\nfunction TimelineAnimationEngine_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineAnimationEngine.prototype._animations;\n/** @type {?} */\nTimelineAnimationEngine.prototype._playersById;\n/** @type {?} */\nTimelineAnimationEngine.prototype.players;\n/** @type {?} */\nTimelineAnimationEngine.prototype._driver;\n/** @type {?} */\nTimelineAnimationEngine.prototype._normalizer;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, AnimationMetadata, sequence, ɵStyleData} from '@angular/animations';\n\nexport const /** @type {?} */ ONE_SECOND = 1000;\n\nexport const /** @type {?} */ ENTER_CLASSNAME = 'ng-enter';\nexport const /** @type {?} */ LEAVE_CLASSNAME = 'ng-leave';\nexport const /** @type {?} */ ENTER_SELECTOR = '.ng-enter';\nexport const /** @type {?} */ LEAVE_SELECTOR = '.ng-leave';\nexport const /** @type {?} */ NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const /** @type {?} */ NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const /** @type {?} */ NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const /** @type {?} */ NG_ANIMATING_SELECTOR = '.ng-animating';\n/**\n * @param {?} value\n * @return {?}\n */\nexport function resolveTimingValue(value: string | number) {\n  if (typeof value == 'number') return value;\n\n  const /** @type {?} */ matches = ( /** @type {?} */((value as string))).match(/^(-?[\\.\\d]+)(m?s)/);\n  if (!matches || matches.length < 2) return 0;\n\n  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n/**\n * @param {?} value\n * @param {?} unit\n * @return {?}\n */\nfunction _convertTimeValueToMS(value: number, unit: string): number {\n  switch (unit) {\n    case 's':\n      return value * ONE_SECOND;\n    default:  // ms or something else\n      return value;\n  }\n}\n/**\n * @param {?} timings\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nexport function resolveTiming(\n    timings: string | number | AnimateTimings, errors: any[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ? /** @type {?} */((\n      <AnimateTimings>timings)) :\n      parseTimeExpression( /** @type {?} */((<string|number>timings)), errors, allowNegativeValues);\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nfunction parseTimeExpression(\n    exp: string | number, errors: string[], allowNegativeValues?: boolean): AnimateTimings {\n  const /** @type {?} */ regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = '';\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: ''};\n    }\n\n    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    if (delayMatch != null) {\n      delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  if (!allowNegativeValues) {\n    let /** @type {?} */ containsErrors = false;\n    let /** @type {?} */ startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(`Duration values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(`Delay values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, `The provided timing value \"${exp}\" is invalid.`);\n    }\n  }\n\n  return {duration, delay, easing};\n}\n/**\n * @param {?} obj\n * @param {?=} destination\n * @return {?}\n */\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => { destination[prop] = obj[prop]; });\n  return destination;\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const /** @type {?} */ normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n/**\n * @param {?} styles\n * @param {?} readPrototype\n * @param {?=} destination\n * @return {?}\n */\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let /** @type {?} */ prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    copyObj(styles, destination);\n  }\n  return destination;\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => element.style[prop] = styles[prop]);\n  }\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      element.style[prop] = '';\n    });\n  }\n}\n/**\n * @param {?} steps\n * @return {?}\n */\nexport function normalizeAnimationEntry(steps: AnimationMetadata | AnimationMetadata[]):\n    AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return /** @type {?} */(( steps as AnimationMetadata));\n}\n\n// this is a naive approach to search/replace\n// TODO: check to see that transforms are not effected\nconst /** @type {?} */ SIMPLE_STYLE_INTERPOLATION_REGEX = /\\$\\w+/g;\nconst /** @type {?} */ ADVANCED_STYLE_INTERPOLATION_REGEX = /\\$\\{([-\\w\\s]+)\\}/g;\n/**\n * @param {?} value\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nexport function validateStyleLocals(\n    value: string | number, locals: {[name: string]: any}, errors: any[]) {\n  if (typeof value == 'string') {\n    matchAndValidate(SIMPLE_STYLE_INTERPOLATION_REGEX, 1, 0, /** @type {?} */(( value as string)), locals, errors);\n    matchAndValidate(ADVANCED_STYLE_INTERPOLATION_REGEX, 2, 1, /** @type {?} */(( value as string)), locals, errors);\n  }\n}\n/**\n * @param {?} regex\n * @param {?} prefixLength\n * @param {?} suffixLength\n * @param {?} str\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nfunction matchAndValidate(\n    regex: RegExp, prefixLength: number, suffixLength: number, str: string,\n    locals: {[name: string]: any}, errors: any[]) {\n  const /** @type {?} */ matches = str.toString().match(regex);\n  if (matches) {\n    matches.forEach(varName => {\n      varName = '$' +\n          varName.substring(prefixLength, varName.length - suffixLength);  // drop the $ or ${}\n      if (!locals.hasOwnProperty(varName)) {\n        errors.push(\n            `Unable to resolve the local animation variable ${varName} in the given list of values`);\n      }\n    });\n  }\n}\n/**\n * @param {?} value\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nexport function interpolateLocals(\n    value: string | number, locals: {[varName: string]: string | number}, errors: any[]): string|\n    number {\n  let /** @type {?} */ original = value.toString();\n  let /** @type {?} */ str = original;\n  str = matchAndReplace(SIMPLE_STYLE_INTERPOLATION_REGEX, 1, 0, str, locals, errors);\n  str = matchAndReplace(ADVANCED_STYLE_INTERPOLATION_REGEX, 2, 1, str, locals, errors);\n\n  // we do this to assert that numeric values stay as they are\n  return str == original ? value : str;\n}\n/**\n * @param {?} regex\n * @param {?} prefixLength\n * @param {?} suffixLength\n * @param {?} str\n * @param {?} locals\n * @param {?} errors\n * @return {?}\n */\nfunction matchAndReplace(\n    regex: RegExp, prefixLength: number, suffixLength: number, str: string,\n    locals: {[varName: string]: string | number}, errors: any[]) {\n  return str.replace(regex, exp => {\n    const /** @type {?} */ varName =\n        '$' + exp.substring(prefixLength, exp.length - suffixLength);  // drop the $ or ${}\n    let /** @type {?} */ localVal = locals[varName];\n    // this means that the value was never overidden by the data passed in by the user\n    if (!locals.hasOwnProperty(varName)) {\n      errors.push(`Please provide a value for the animation variable ${exp}`);\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n}\n/**\n * @param {?} iterator\n * @return {?}\n */\nexport function iteratorToArray(iterator: any): any[] {\n  const /** @type {?} */ arr: any[] = [];\n  let /** @type {?} */ item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimateTimings, ɵStyleData} from '@angular/animations';\n\nexport interface AstVisitor {\n  visitTrigger(ast: TriggerAst, context: any): any;\n  visitState(ast: StateAst, context: any): any;\n  visitTransition(ast: TransitionAst, context: any): any;\n  visitSequence(ast: SequenceAst, context: any): any;\n  visitGroup(ast: GroupAst, context: any): any;\n  visitAnimate(ast: AnimateAst, context: any): any;\n  visitStyle(ast: StyleAst, context: any): any;\n  visitKeyframes(ast: KeyframesAst, context: any): any;\n  visitReference(ast: ReferenceAst, context: any): any;\n  visitAnimateChild(ast: AnimateChildAst, context: any): any;\n  visitAnimateRef(ast: AnimateRefAst, context: any): any;\n  visitQuery(ast: QueryAst, context: any): any;\n  visitStagger(ast: StaggerAst, context: any): any;\n  visitTiming(ast: TimingAst, context: any): any;\n}\n/**\n * @abstract\n */\nexport abstract class Ast {\n/**\n * @abstract\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisit(ast: AstVisitor, context: any) {}\npublic locals: {[name: string]: any}|null;\n}\n\nfunction Ast_tsickle_Closure_declarations() {\n/** @type {?} */\nAst.prototype.locals;\n}\n\nexport class TriggerAst extends Ast {\npublic queryCount: number = 0;\npublic depCount: number = 0;\n/**\n * @param {?} name\n * @param {?} states\n * @param {?} transitions\n */\nconstructor(public name: string,\npublic states: StateAst[],\npublic transitions: TransitionAst[]) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitTrigger(this, context); }\n}\n\nfunction TriggerAst_tsickle_Closure_declarations() {\n/** @type {?} */\nTriggerAst.prototype.queryCount;\n/** @type {?} */\nTriggerAst.prototype.depCount;\n/** @type {?} */\nTriggerAst.prototype.name;\n/** @type {?} */\nTriggerAst.prototype.states;\n/** @type {?} */\nTriggerAst.prototype.transitions;\n}\n\nexport class StateAst extends Ast {\n/**\n * @param {?} name\n * @param {?} style\n */\nconstructor(public name: string,\npublic style: StyleAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitState(this, context); }\n}\n\nfunction StateAst_tsickle_Closure_declarations() {\n/** @type {?} */\nStateAst.prototype.name;\n/** @type {?} */\nStateAst.prototype.style;\n}\n\nexport class TransitionAst extends Ast {\npublic queryCount: number = 0;\npublic depCount: number = 0;\n/**\n * @param {?} matchers\n * @param {?} animation\n */\nconstructor(\npublic matchers: ((fromState: string, toState: string) => boolean)[],\npublic animation: Ast) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitTransition(this, context); }\n}\n\nfunction TransitionAst_tsickle_Closure_declarations() {\n/** @type {?} */\nTransitionAst.prototype.queryCount;\n/** @type {?} */\nTransitionAst.prototype.depCount;\n/** @type {?} */\nTransitionAst.prototype.matchers;\n/** @type {?} */\nTransitionAst.prototype.animation;\n}\n\nexport class SequenceAst extends Ast {\n/**\n * @param {?} steps\n */\nconstructor(public steps: Ast[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitSequence(this, context); }\n}\n\nfunction SequenceAst_tsickle_Closure_declarations() {\n/** @type {?} */\nSequenceAst.prototype.steps;\n}\n\nexport class GroupAst extends Ast {\n/**\n * @param {?} steps\n */\nconstructor(public steps: Ast[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitGroup(this, context); }\n}\n\nfunction GroupAst_tsickle_Closure_declarations() {\n/** @type {?} */\nGroupAst.prototype.steps;\n}\n\nexport class AnimateAst extends Ast {\n/**\n * @param {?} timings\n * @param {?} style\n */\nconstructor(public timings: TimingAst,\npublic style: StyleAst|KeyframesAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitAnimate(this, context); }\n}\n\nfunction AnimateAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimateAst.prototype.timings;\n/** @type {?} */\nAnimateAst.prototype.style;\n}\n\nexport class StyleAst extends Ast {\npublic isEmptyStep = false;\n/**\n * @param {?} styles\n * @param {?} easing\n * @param {?} offset\n */\nconstructor(\npublic styles: (ɵStyleData|string)[],\npublic easing: string|null,\npublic offset: number|null) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitStyle(this, context); }\n}\n\nfunction StyleAst_tsickle_Closure_declarations() {\n/** @type {?} */\nStyleAst.prototype.isEmptyStep;\n/** @type {?} */\nStyleAst.prototype.styles;\n/** @type {?} */\nStyleAst.prototype.easing;\n/** @type {?} */\nStyleAst.prototype.offset;\n}\n\nexport class KeyframesAst extends Ast {\n/**\n * @param {?} styles\n */\nconstructor(public styles: StyleAst[]) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitKeyframes(this, context); }\n}\n\nfunction KeyframesAst_tsickle_Closure_declarations() {\n/** @type {?} */\nKeyframesAst.prototype.styles;\n}\n\nexport class ReferenceAst extends Ast {\n/**\n * @param {?} animation\n */\nconstructor(public animation: Ast) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitReference(this, context); }\n}\n\nfunction ReferenceAst_tsickle_Closure_declarations() {\n/** @type {?} */\nReferenceAst.prototype.animation;\n}\n\nexport class AnimateChildAst extends Ast {\nconstructor() { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitAnimateChild(this, context); }\n}\nexport class AnimateRefAst extends Ast {\n/**\n * @param {?} animation\n */\nconstructor(public animation: ReferenceAst) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitAnimateRef(this, context); }\n}\n\nfunction AnimateRefAst_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimateRefAst.prototype.animation;\n}\n\nexport class QueryAst extends Ast {\npublic originalSelector: string;\n/**\n * @param {?} selector\n * @param {?} multi\n * @param {?} includeSelf\n * @param {?} animation\n */\nconstructor(\npublic selector: string,\npublic multi: boolean,\npublic includeSelf: boolean,\npublic animation: Ast) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitQuery(this, context); }\n}\n\nfunction QueryAst_tsickle_Closure_declarations() {\n/** @type {?} */\nQueryAst.prototype.originalSelector;\n/** @type {?} */\nQueryAst.prototype.selector;\n/** @type {?} */\nQueryAst.prototype.multi;\n/** @type {?} */\nQueryAst.prototype.includeSelf;\n/** @type {?} */\nQueryAst.prototype.animation;\n}\n\nexport class StaggerAst extends Ast {\n/**\n * @param {?} timings\n * @param {?} animation\n */\nconstructor(public timings: AnimateTimings,\npublic animation: Ast) { super(); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitStagger(this, context); }\n}\n\nfunction StaggerAst_tsickle_Closure_declarations() {\n/** @type {?} */\nStaggerAst.prototype.timings;\n/** @type {?} */\nStaggerAst.prototype.animation;\n}\n\nexport class TimingAst extends Ast {\n/**\n * @param {?} duration\n * @param {?=} delay\n * @param {?=} easing\n */\nconstructor(\npublic duration: number,\npublic delay: number = 0,\npublic easing: string|null = null) {\n    super();\n  }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitTiming(this, context); }\n}\n\nfunction TimingAst_tsickle_Closure_declarations() {\n/** @type {?} */\nTimingAst.prototype.duration;\n/** @type {?} */\nTimingAst.prototype.delay;\n/** @type {?} */\nTimingAst.prototype.easing;\n}\n\nexport class DynamicTimingAst extends TimingAst {\n/**\n * @param {?} value\n */\nconstructor(public value: string) { super(0, 0, ''); }\n/**\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nvisit(visitor: AstVisitor, context: any): any { return visitor.visitTiming(this, context); }\n}\n\nfunction DynamicTimingAst_tsickle_Closure_declarations() {\n/** @type {?} */\nDynamicTimingAst.prototype.value;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimateTimings, AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationAnimateRefMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationQueryMetadata, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata, style, ɵStyleData} from '@angular/animations';\n\nimport {getOrSetAsInMap} from '../render/shared';\nimport {ENTER_SELECTOR, LEAVE_SELECTOR, NG_ANIMATING_SELECTOR, NG_TRIGGER_SELECTOR, copyObj, copyStyles, normalizeAnimationEntry, resolveTiming, validateStyleLocals} from '../util';\n\nimport {AnimateAst, AnimateChildAst, AnimateRefAst, Ast, DynamicTimingAst, GroupAst, KeyframesAst, QueryAst, ReferenceAst, SequenceAst, StaggerAst, StateAst, StyleAst, TimingAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\nimport {parseTransitionExpr} from './animation_transition_expr';\n/**\n * @param {?} metadata\n * @param {?} errors\n * @return {?}\n */\nexport function buildAnimationAst(\n    metadata: AnimationMetadata | AnimationMetadata[], errors: any[]): Ast {\n  return new AnimationAstBuilderVisitor().build(metadata, errors);\n}\n\nconst /** @type {?} */ LEAVE_TOKEN = ':leave';\nconst /** @type {?} */ LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\nconst /** @type {?} */ ENTER_TOKEN = ':enter';\nconst /** @type {?} */ ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\nexport class AnimationAstBuilderVisitor implements AnimationDslVisitor {\n/**\n * @param {?} metadata\n * @param {?} errors\n * @return {?}\n */\nbuild(metadata: AnimationMetadata|AnimationMetadata[], errors: any[]): Ast {\n    const /** @type {?} */ context = new AnimationAstBuilderContext(errors);\n    return /** @type {?} */(( visitAnimationNode(this, normalizeAnimationEntry(metadata), context) as Ast));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitTrigger(metadata: AnimationTriggerMetadata, context: AnimationAstBuilderContext):\n      TriggerAst {\n    let /** @type {?} */ queryCount = context.queryCount = 0;\n    let /** @type {?} */ depCount = context.depCount = 0;\n    const /** @type {?} */ states: StateAst[] = [];\n    const /** @type {?} */ transitions: TransitionAst[] = [];\n    metadata.definitions.forEach(def => {\n      if (def.type == AnimationMetadataType.State) {\n        const /** @type {?} */ stateDef = /** @type {?} */(( def as AnimationStateMetadata));\n        const /** @type {?} */ name = stateDef.name;\n        name.split(/\\s*,\\s*/).forEach(n => {\n          stateDef.name = n;\n          states.push(this.visitState(stateDef, context));\n        });\n        stateDef.name = name;\n      } else if (def.type == AnimationMetadataType.Transition) {\n        const /** @type {?} */ transition = this.visitTransition( /** @type {?} */((def as AnimationTransitionMetadata)), context);\n        queryCount += transition.queryCount;\n        depCount += transition.depCount;\n        transitions.push(transition);\n      } else {\n        context.errors.push(\n            'only state() and transition() definitions can sit inside of a trigger()');\n      }\n    });\n    const /** @type {?} */ ast = new TriggerAst(metadata.name, states, transitions);\n    ast.queryCount = queryCount;\n    ast.depCount = depCount;\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitState(metadata: AnimationStateMetadata, context: AnimationAstBuilderContext): StateAst {\n    return new StateAst(metadata.name, this.visitStyle(metadata.styles, context));\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitTransition(metadata: AnimationTransitionMetadata, context: AnimationAstBuilderContext):\n      TransitionAst {\n    context.queryCount = 0;\n    context.depCount = 0;\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);\n    const /** @type {?} */ ast = new TransitionAst(matchers, entry);\n    ast.locals = normalizeLocals(metadata.locals);\n    ast.queryCount = context.queryCount;\n    ast.depCount = context.depCount;\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitSequence(metadata: AnimationSequenceMetadata, context: AnimationAstBuilderContext):\n      SequenceAst {\n    const /** @type {?} */ ast = new SequenceAst(metadata.steps.map(s => visitAnimationNode(this, s, context)));\n    if (metadata.locals && Object.keys(metadata.locals).length) {\n      ast.locals = metadata.locals;\n    }\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitGroup(metadata: AnimationGroupMetadata, context: AnimationAstBuilderContext): GroupAst {\n    const /** @type {?} */ currentTime = context.currentTime;\n    let /** @type {?} */ furthestTime = 0;\n    const /** @type {?} */ steps = metadata.steps.map(step => {\n      context.currentTime = currentTime;\n      const /** @type {?} */ innerAst = visitAnimationNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n      return innerAst;\n    });\n\n    context.currentTime = furthestTime;\n    const /** @type {?} */ ast = new GroupAst(steps);\n    if (metadata.locals && Object.keys(metadata.locals).length) {\n      ast.locals = metadata.locals;\n    }\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(metadata: AnimationAnimateMetadata, context: AnimationAstBuilderContext):\n      AnimateAst {\n    const /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);\n    context.currentAnimateTimings = timingAst;\n\n    let /** @type {?} */ styles: StyleAst|KeyframesAst;\n    let /** @type {?} */ styleMetadata: AnimationMetadata = metadata.styles ? metadata.styles : style({});\n    if (styleMetadata.type == AnimationMetadataType.Keyframes) {\n      styles = this.visitKeyframes( /** @type {?} */((styleMetadata as AnimationKeyframesSequenceMetadata)), context);\n    } else {\n      let /** @type {?} */ styleMetadata = /** @type {?} */(( metadata.styles as AnimationStyleMetadata));\n      let /** @type {?} */ isEmpty = false;\n      if (!styleMetadata) {\n        isEmpty = true;\n        const /** @type {?} */ newStyleData: {[prop: string]: string | number} = {};\n        if (timingAst.easing) {\n          newStyleData['easing'] = timingAst.easing;\n        }\n        styleMetadata = style(newStyleData);\n      }\n      context.currentTime += timingAst.duration + timingAst.delay;\n      const /** @type {?} */ styleAst = this.visitStyle(styleMetadata, context);\n      styleAst.isEmptyStep = isEmpty;\n      styles = styleAst;\n    }\n\n    context.currentAnimateTimings = null;\n    return new AnimateAst(timingAst, styles);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitStyle(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext): StyleAst {\n    const /** @type {?} */ ast = this._makeStyleAst(metadata, context);\n    this._validateStyleAst(ast, context);\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nprivate _makeStyleAst(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):\n      StyleAst {\n    const /** @type {?} */ styles: (ɵStyleData | string)[] = [];\n    if (Array.isArray(metadata.styles)) {\n      ( /** @type {?} */((metadata.styles as(ɵStyleData | string)[]))).forEach(styleTuple => {\n        if (typeof styleTuple == 'string') {\n          if (styleTuple == AUTO_STYLE) {\n            styles.push( /** @type {?} */((styleTuple as string)));\n          } else {\n            context.errors.push(`The provided style string value ${styleTuple} is not allowed.`);\n          }\n        } else {\n          styles.push( /** @type {?} */((styleTuple as ɵStyleData)));\n        }\n      })\n    } else {\n      styles.push(metadata.styles);\n    }\n\n    let /** @type {?} */ collectedEasing: string|null = null;\n    styles.forEach(styleData => {\n      if (isObject(styleData)) {\n        const /** @type {?} */ styleMap = /** @type {?} */(( styleData as ɵStyleData));\n        const /** @type {?} */ easing = styleMap['easing'];\n        if (easing) {\n          collectedEasing = /** @type {?} */(( easing as string));\n          delete styleMap['easing'];\n        }\n      }\n    });\n    return new StyleAst(styles, collectedEasing, metadata.offset);\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nprivate _validateStyleAst(ast: StyleAst, context: AnimationAstBuilderContext): void {\n    const /** @type {?} */ timings = context.currentAnimateTimings;\n    let /** @type {?} */ endTime = context.currentTime;\n    let /** @type {?} */ startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n\n    ast.styles.forEach(tuple => {\n      if (typeof tuple == 'string') return;\n\n      Object.keys(tuple).forEach(prop => {\n        const /** @type {?} */ collectedStyles = context.collectedStyles[ /** @type {?} */((context.currentQuerySelector))];\n        const /** @type {?} */ collectedEntry = collectedStyles[prop];\n        let /** @type {?} */ updateCollectedStyle = true;\n        if (collectedEntry) {\n          if (startTime != endTime && startTime >= collectedEntry.startTime &&\n              endTime <= collectedEntry.endTime) {\n            context.errors.push(\n                `The CSS property \"${prop}\" that exists between the times of \"${collectedEntry.startTime}ms\" and \"${collectedEntry.endTime}ms\" is also being animated in a parallel animation between the times of \"${startTime}ms\" and \"${endTime}ms\"`);\n            updateCollectedStyle = false;\n          }\n\n          // we always choose the smaller start time value since we\n          // want to have a record of the entire animation window where\n          // the style property is being animated in between\n          startTime = collectedEntry.startTime;\n        }\n\n        if (updateCollectedStyle) {\n          collectedStyles[prop] = {startTime, endTime};\n        }\n\n        if (context.locals) {\n          validateStyleLocals(tuple[prop], context.locals, context.errors);\n        }\n      });\n    });\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitKeyframes(metadata: AnimationKeyframesSequenceMetadata, context: AnimationAstBuilderContext):\n      KeyframesAst {\n    if (!context.currentAnimateTimings) {\n      context.errors.push(`keyframes() must be placed inside of a call to animate()`);\n      return new KeyframesAst([]);\n    }\n\n    const /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;\n\n    let /** @type {?} */ totalKeyframesWithOffsets = 0;\n    const /** @type {?} */ offsets: number[] = [];\n    let /** @type {?} */ offsetsOutOfOrder = false;\n    let /** @type {?} */ keyframesOutOfRange = false;\n    let /** @type {?} */ previousOffset: number = 0;\n\n    const /** @type {?} */ keyframes: StyleAst[] = metadata.steps.map(styles => {\n      const /** @type {?} */ style = this._makeStyleAst(styles, context);\n      let /** @type {?} */ offsetVal: number|null =\n          style.offset != null ? style.offset : consumeOffset(style.styles);\n      let /** @type {?} */ offset: number = 0;\n      if (offsetVal != null) {\n        totalKeyframesWithOffsets++;\n        offset = style.offset = offsetVal;\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n      return style;\n    });\n\n    if (keyframesOutOfRange) {\n      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);\n    }\n\n    if (offsetsOutOfOrder) {\n      context.errors.push(`Please ensure that all keyframe offsets are in order`);\n    }\n\n    const /** @type {?} */ length = metadata.steps.length;\n    let /** @type {?} */ generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n    }\n\n    const /** @type {?} */ limit = length - 1;\n    const /** @type {?} */ currentTime = context.currentTime;\n    const /** @type {?} */ currentAnimateTimings = /** @type {?} */(( context.currentAnimateTimings));\n    const /** @type {?} */ animateDuration = currentAnimateTimings.duration;\n    keyframes.forEach((kf, i) => {\n      const /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n      const /** @type {?} */ durationUpToThisFrame = offset * animateDuration;\n      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n      currentAnimateTimings.duration = durationUpToThisFrame;\n      this._validateStyleAst(kf, context);\n      kf.offset = offset;\n    });\n\n    return new KeyframesAst(keyframes);\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitReference(metadata: AnimationReferenceMetadata, context: AnimationAstBuilderContext):\n      ReferenceAst {\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const /** @type {?} */ ast = new ReferenceAst(entry);\n    if (metadata.locals) {\n      ast.locals = normalizeLocals(metadata.locals);\n    }\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitAnimateChild(metadata: AnimationAnimateChildMetadata, context: AnimationAstBuilderContext):\n      AnimateChildAst {\n    context.depCount++;\n    const /** @type {?} */ ast = new AnimateChildAst();\n    if (metadata.locals) {\n      ast.locals = normalizeLocals(metadata.locals);\n    }\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitAnimateRef(metadata: AnimationAnimateRefMetadata, context: AnimationAstBuilderContext):\n      AnimateRefAst {\n    const /** @type {?} */ animation = this.visitReference(metadata.animation, context);\n    const /** @type {?} */ ast = new AnimateRefAst(animation);\n    ast.locals = normalizeLocals(metadata.locals);\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitQuery(metadata: AnimationQueryMetadata, context: AnimationAstBuilderContext): QueryAst {\n    const /** @type {?} */ parentSelector = /** @type {?} */(( context.currentQuerySelector));\n\n    context.queryCount++;\n    context.currentQuery = metadata;\n    const [selector, includeSelf] = normalizeSelector(metadata.selector);\n    context.currentQuerySelector =\n        parentSelector.length ? (parentSelector + ' ' + selector) : selector;\n    getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});\n\n    const /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    context.currentQuery = null;\n    context.currentQuerySelector = parentSelector;\n\n    const /** @type {?} */ ast = new QueryAst(selector, metadata.multi, includeSelf, entry);\n    ast.originalSelector = metadata.selector;\n    if (metadata.locals && Object.keys(metadata.locals).length) {\n      ast.locals = metadata.locals;\n    }\n    return ast;\n  }\n/**\n * @param {?} metadata\n * @param {?} context\n * @return {?}\n */\nvisitStagger(metadata: AnimationStaggerMetadata, context: AnimationAstBuilderContext):\n      StaggerAst {\n    if (!context.currentQuery || !context.currentQuery.multi) {\n      context.errors.push(`stagger() can only be used inside of queryAll()`);\n    }\n    const /** @type {?} */ timings = metadata.timings === 'full' ?\n        {duration: 0, delay: 0, easing: 'full'} :\n        resolveTiming(metadata.timings, context.errors, true);\n    const /** @type {?} */ animation =\n        visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);\n    return new StaggerAst(timings, animation);\n  }\n}\n/**\n * @param {?} selector\n * @return {?}\n */\nfunction normalizeSelector(selector: string): [string, boolean] {\n  const /** @type {?} */ hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == '&') ? true : false;\n  if (hasAmpersand) {\n    selector = selector.replace(/\\s*&\\s*,?/g, '');\n  }\n\n  selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)\n                 .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)\n                 .replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n                 .replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1))\n                 .replace(/:animating/g, NG_ANIMATING_SELECTOR);\n\n  return [selector, hasAmpersand];\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction normalizeLocals(obj: {[key: string]: any} | null): {[key: string]: any}|null {\n  return obj ? copyObj(obj) : null;\n}\n/**\n * @param {?} args\n * @return {?}\n */\nfunction countArgs(args: any[]): number {\n  return args.reduce((count, arg) => (arg != null ? 1 : 0) + count, 0);\n}\n\nexport type StyleTimeTuple = {\n  startTime: number; endTime: number;\n};\nexport class AnimationAstBuilderContext {\npublic queryCount: number = 0;\npublic depCount: number = 0;\npublic currentTransition: AnimationTransitionMetadata|null = null;\npublic currentQuery: AnimationQueryMetadata|null = null;\npublic currentQuerySelector: string|null = null;\npublic currentAnimateTimings: TimingAst|null = null;\npublic currentTime: number = 0;\npublic collectedStyles: {[selectorName: string]: {[propName: string]: StyleTimeTuple}} = {};\npublic locals: {[name: string]: any}|null = null;\n/**\n * @param {?} errors\n */\nconstructor(public errors: any[]) {\n    // this is for the rootElement's selector\n    const ROOT_SELECTOR = '';\n    this.currentQuerySelector = ROOT_SELECTOR;\n    this.collectedStyles[ROOT_SELECTOR] = {};\n  }\n}\n\nfunction AnimationAstBuilderContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationAstBuilderContext.prototype.queryCount;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.depCount;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentTransition;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentQuery;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentQuerySelector;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.currentTime;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.collectedStyles;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.locals;\n/** @type {?} */\nAnimationAstBuilderContext.prototype.errors;\n}\n\n/**\n * @param {?} styles\n * @return {?}\n */\nfunction consumeOffset(styles: ɵStyleData | string | (ɵStyleData | string)[]): number|null {\n  if (typeof styles == 'string') return null;\n\n  let /** @type {?} */ offset: number|null = null;\n\n  if (Array.isArray(styles)) {\n    styles.forEach(styleTuple => {\n      if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {\n        const /** @type {?} */ obj = /** @type {?} */(( styleTuple as ɵStyleData));\n        offset = parseFloat( /** @type {?} */((obj['offset'] as string)));\n        delete obj['offset'];\n      }\n    });\n  } else if (isObject(styles) && styles.hasOwnProperty('offset')) {\n    const /** @type {?} */ obj = /** @type {?} */(( styles as ɵStyleData));\n    offset = parseFloat( /** @type {?} */((obj['offset'] as string)));\n    delete obj['offset'];\n  }\n  return offset;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isObject(value: any): boolean {\n  return !Array.isArray(value) && typeof value == 'object';\n}\n/**\n * @param {?} value\n * @param {?} errors\n * @return {?}\n */\nfunction constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {\n  let /** @type {?} */ timings: AnimateTimings|null = null;\n  if (value.hasOwnProperty('duration')) {\n    timings = /** @type {?} */(( value as AnimateTimings));\n  } else if (typeof value == 'number') {\n    const /** @type {?} */ duration = resolveTiming( /** @type {?} */((value as number)), errors).duration;\n    return new TimingAst( /** @type {?} */((value as number)), 0, '');\n  }\n\n  const /** @type {?} */ strValue = /** @type {?} */(( value as string));\n  const /** @type {?} */ isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '$');\n  if (isDynamic) {\n    return new DynamicTimingAst(strValue);\n  }\n\n  timings = timings || resolveTiming(strValue, errors);\n  return new TimingAst(timings.duration, timings.delay, timings.easing);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\nexport class ElementInstructionMap {\nprivate _map = new Map<any, AnimationTimelineInstruction[]>();\n/**\n * @param {?} element\n * @return {?}\n */\nconsume(element: any): AnimationTimelineInstruction[] {\n    let /** @type {?} */ instructions = this._map.get(element);\n    if (instructions) {\n      this._map.delete(element);\n    } else {\n      instructions = [];\n    }\n    return instructions;\n  }\n/**\n * @param {?} element\n * @param {?} instructions\n * @return {?}\n */\nappend(element: any, instructions: AnimationTimelineInstruction[]) {\n    let /** @type {?} */ existingInstructions = this._map.get(element);\n    if (!existingInstructions) {\n      this._map.set(element, existingInstructions = []);\n    }\n    existingInstructions.push(...instructions);\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nhas(element: any): boolean { return this._map.has(element); }\n/**\n * @return {?}\n */\nclear() { this._map.clear(); }\n}\n\nfunction ElementInstructionMap_tsickle_Closure_declarations() {\n/** @type {?} */\nElementInstructionMap.prototype._map;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationPlayer, NoopAnimationPlayer} from '@angular/animations';\n\n\n\n/**\n * @experimental\n */\nexport class NoopAnimationDriver implements AnimationDriver {\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): AnimationPlayer {\n    return new NoopAnimationPlayer();\n  }\n}\n\n/**\n * @experimental\n */\nexport abstract class AnimationDriver {\n  static NOOP: AnimationDriver = new NoopAnimationDriver();\n\n  abstract computeStyle(element: any, prop: string, defaultValue?: string): string;\n\n  abstract animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing?: string|null, previousPlayers?: any[]): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\nimport {AnimationTimelineInstruction} from './animation_timeline_instruction';\n\nexport interface AnimationTransitionInstruction extends AnimationEngineInstruction {\n  element: any;\n  triggerName: string;\n  isRemovalTransition: boolean;\n  fromState: string;\n  fromStyles: ɵStyleData;\n  toState: string;\n  toStyles: ɵStyleData;\n  timelines: AnimationTimelineInstruction[];\n  queriedElements: any[];\n  preStyleProps: Map<any, {[prop: string]: boolean}>;\n  postStyleProps: Map<any, {[prop: string]: boolean}>;\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?} isRemovalTransition\n * @param {?} fromStyles\n * @param {?} toStyles\n * @param {?} timelines\n * @param {?} queriedElements\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @return {?}\n */\nexport function createTransitionInstruction(\n    element: any, triggerName: string, fromState: string, toState: string,\n    isRemovalTransition: boolean, fromStyles: ɵStyleData, toStyles: ɵStyleData,\n    timelines: AnimationTimelineInstruction[], queriedElements: any[],\n    preStyleProps: Map<any, {[prop: string]: boolean}>,\n    postStyleProps: Map<any, {[prop: string]: boolean}>): AnimationTransitionInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TransitionAnimation,\n    element,\n    triggerName,\n    isRemovalTransition,\n    fromState,\n    fromStyles,\n    toState,\n    toStyles,\n    timelines,\n    queriedElements,\n    preStyleProps,\n    postStyleProps\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵStyleData} from '@angular/animations';\nimport {AnimationEngineInstruction, AnimationTransitionInstructionType} from '../render/animation_engine_instruction';\n\nexport interface AnimationTimelineInstruction extends AnimationEngineInstruction {\n  element: any;\n  keyframes: ɵStyleData[];\n  preStyleProps: string[];\n  postStyleProps: string[];\n  duration: number;\n  delay: number;\n  totalTime: number;\n  easing: string|null;\n  stretchStartingKeyframe?: boolean;\n  subTimeline: boolean;\n}\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} preStyleProps\n * @param {?} postStyleProps\n * @param {?} duration\n * @param {?} delay\n * @param {?=} easing\n * @param {?=} subTimeline\n * @return {?}\n */\nexport function createTimelineInstruction(\n    element: any, keyframes: ɵStyleData[], preStyleProps: string[], postStyleProps: string[],\n    duration: number, delay: number, easing: string | null = null,\n    subTimeline: boolean = false): AnimationTimelineInstruction {\n  return {\n    type: AnimationTransitionInstructionType.TimelineAnimation,\n    element,\n    keyframes,\n    preStyleProps,\n    postStyleProps,\n    duration,\n    delay,\n    totalTime: duration + delay, easing, subTimeline\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationAnimateRefMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationQueryMetadata, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata} from '@angular/animations';\n\nexport interface AnimationDslVisitor {\n  visitTrigger(ast: AnimationTriggerMetadata, context: any): any;\n  visitState(ast: AnimationStateMetadata, context: any): any;\n  visitTransition(ast: AnimationTransitionMetadata, context: any): any;\n  visitSequence(ast: AnimationSequenceMetadata, context: any): any;\n  visitGroup(ast: AnimationGroupMetadata, context: any): any;\n  visitAnimate(ast: AnimationAnimateMetadata, context: any): any;\n  visitStyle(ast: AnimationStyleMetadata, context: any): any;\n  visitKeyframes(ast: AnimationKeyframesSequenceMetadata, context: any): any;\n  visitReference(ast: AnimationReferenceMetadata, context: any): any;\n  visitAnimateChild(ast: AnimationAnimateChildMetadata, context: any): any;\n  visitAnimateRef(ast: AnimationAnimateRefMetadata, context: any): any;\n  visitQuery(ast: AnimationQueryMetadata, context: any): any;\n  visitStagger(ast: AnimationStaggerMetadata, context: any): any;\n}\n/**\n * @param {?} visitor\n * @param {?} node\n * @param {?} context\n * @return {?}\n */\nexport function visitAnimationNode(\n    visitor: AnimationDslVisitor, node: AnimationMetadata, context: any) {\n  switch (node.type) {\n    case AnimationMetadataType.Trigger:\n      return visitor.visitTrigger( /** @type {?} */((node as AnimationTriggerMetadata)), context);\n    case AnimationMetadataType.State:\n      return visitor.visitState( /** @type {?} */((node as AnimationStateMetadata)), context);\n    case AnimationMetadataType.Transition:\n      return visitor.visitTransition( /** @type {?} */((node as AnimationTransitionMetadata)), context);\n    case AnimationMetadataType.Sequence:\n      return visitor.visitSequence( /** @type {?} */((node as AnimationSequenceMetadata)), context);\n    case AnimationMetadataType.Group:\n      return visitor.visitGroup( /** @type {?} */((node as AnimationGroupMetadata)), context);\n    case AnimationMetadataType.Animate:\n      return visitor.visitAnimate( /** @type {?} */((node as AnimationAnimateMetadata)), context);\n    case AnimationMetadataType.Keyframes:\n      return visitor.visitKeyframes( /** @type {?} */((node as AnimationKeyframesSequenceMetadata)), context);\n    case AnimationMetadataType.Style:\n      return visitor.visitStyle( /** @type {?} */((node as AnimationStyleMetadata)), context);\n    case AnimationMetadataType.Reference:\n      return visitor.visitReference( /** @type {?} */((node as AnimationReferenceMetadata)), context);\n    case AnimationMetadataType.AnimateChild:\n      return visitor.visitAnimateChild( /** @type {?} */((node as AnimationAnimateChildMetadata)), context);\n    case AnimationMetadataType.AnimateRef:\n      return visitor.visitAnimateRef( /** @type {?} */((node as AnimationAnimateRefMetadata)), context);\n    case AnimationMetadataType.Query:\n      return visitor.visitQuery( /** @type {?} */((node as AnimationQueryMetadata)), context);\n    case AnimationMetadataType.Stagger:\n      return visitor.visitStagger( /** @type {?} */((node as AnimationStaggerMetadata)), context);\n    default:\n      throw new Error(`Unable to resolve animation metadata node #${node.type}`);\n  }\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn = (fromState: any, toState: any) => boolean;\n/**\n * @param {?} transitionValue\n * @param {?} errors\n * @return {?}\n */\nexport function parseTransitionExpr(\n    transitionValue: string | TransitionMatcherFn, errors: string[]): TransitionMatcherFn[] {\n  const /** @type {?} */ expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    ( /** @type {?} */((<string>transitionValue)))\n        .split(/\\s*,\\s*/)\n        .forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push( /** @type {?} */((<TransitionMatcherFn>transitionValue)));\n  }\n  return expressions;\n}\n/**\n * @param {?} eventStr\n * @param {?} expressions\n * @param {?} errors\n * @return {?}\n */\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: string[]) {\n  if (eventStr[0] == ':') {\n    eventStr = parseAnimationAlias(eventStr, errors);\n  }\n  const /** @type {?} */ match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(`The provided transition expression \"${eventStr}\" is not supported`);\n    return expressions;\n  }\n\n  const /** @type {?} */ fromState = match[1];\n  const /** @type {?} */ separator = match[2];\n  const /** @type {?} */ toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction parseAnimationAlias(alias: string, errors: string[]): string {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    default:\n      errors.push(`The transition alias value \"${alias}\" is not supported`);\n      return '* => *';\n  }\n}\n/**\n * @param {?} lhs\n * @param {?} rhs\n * @return {?}\n */\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  return (fromState: any, toState: any): boolean => {\n    let /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;\n\n    if (!lhsMatch && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? lhs === 'true' : lhs === 'false';\n    }\n    if (!rhsMatch && typeof toState === 'boolean') {\n      rhsMatch = toState ? rhs === 'true' : rhs === 'false';\n    }\n\n    return lhsMatch && rhsMatch;\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n/**\n * @param {?} players\n * @return {?}\n */\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n/**\n * @param {?} driver\n * @param {?} normalizer\n * @param {?} element\n * @param {?} keyframes\n * @param {?=} preStyles\n * @param {?=} postStyles\n * @return {?}\n */\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData = {},\n    postStyles: ɵStyleData = {}): ɵStyleData[] {\n  const /** @type {?} */ errors: string[] = [];\n  const /** @type {?} */ normalizedKeyframes: ɵStyleData[] = [];\n  let /** @type {?} */ previousOffset = -1;\n  let /** @type {?} */ previousKeyframe: ɵStyleData|null = null;\n  keyframes.forEach(kf => {\n    const /** @type {?} */ offset = /** @type {?} */(( kf['offset'] as number));\n    const /** @type {?} */ isSameOffset = offset == previousOffset;\n    const /** @type {?} */ normalizedKeyframe: ɵStyleData = (isSameOffset && previousKeyframe) || {};\n    Object.keys(kf).forEach(prop => {\n      let /** @type {?} */ normalizedProp = prop;\n      let /** @type {?} */ normalizedValue = kf[prop];\n      if (normalizedValue == PRE_STYLE) {\n        normalizedValue = preStyles[prop];\n      } else if (normalizedValue == AUTO_STYLE) {\n        normalizedValue = postStyles[prop];\n      } else if (prop != 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(prop, errors);\n        normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, kf[prop], errors);\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const /** @type {?} */ LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n/**\n * @param {?} player\n * @param {?} eventName\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player.totalTime)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player.totalTime)));\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)));\n      break;\n  }\n}\n/**\n * @param {?} e\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  return makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} defaultValue\n * @return {?}\n */\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let /** @type {?} */ value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n/**\n * @param {?} command\n * @return {?}\n */\nexport function parseTimelineCommand(command: string): [string, string] {\n  const /** @type {?} */ separatorPos = command.indexOf(':');\n  const /** @type {?} */ id = command.substring(1, separatorPos);\n  const /** @type {?} */ action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n"],"names":["DomAnimationEngine","prototype","registerTrigger","componentId","namespaceId","hostElement","name","metadata","cacheKey","trigger","this","_triggerCache","_transitionEngine","listen","element","eventName","eventPhase","callback","Object","defineProperty","__extends","NoopAnimationEngine","_super","setProperty","property","value","charAt","_a","parseTimelineCommand","id","action","args","_timelineEngine","command","namespacedName","storageProp","makeStorageProp","oldValue","DEFAULT_STATE_VALUE$1","_changes","push","newValue","triggerName","triggerStateStyles","_triggerStyles","fromStateStyles","DEFAULT_STATE_STYLES","eraseStyles","listeners","_listeners","get","tuple","handleListener","listener","data","phase","event","makeAnimationEvent$1","onStartCallbacks","onDoneCallbacks","forEach","change","_this","_flaggedRemovals","Array","from","keys","listenersToKeep","filter","l","doRemove","length","set","fn","clear","WebAnimationsPlayer","keyframes","options","previousPlayers","_onDoneFns","_onStartFns","_onDestroyFns","_initialized","_finished","_started","_destroyed","time","parentPlayer","_duration","_delay","previousStyles","_onFinish","init","map","styles","copyStyles","previousStyleProps","missingStyleProps_1","prop","startingKeyframe_1","hasOwnProperty","self_1","i","_loop_1","_player","_triggerWebAnimation","onStart","onDone","onDestroy","hasStarted","finish","reset","play","setPosition","p","currentTime","getPosition","configurable","beforeDestroy","_finalKeyframe","fill","delay","easing","playerOptions","instruction","rootElement","allConsumedElements","Set","allSubElements","allNewPlayers","timelines","timelineInstruction","_angular_animations","NoopAnimationPlayer","isQueriedElement","EMPTY_PLAYER_ARRAY","has","_previousPlayers","getRealPlayer","postStyles","postStylesMap","normalizeKeyframes","_driver","_normalizer","preStyles","player","_buildPlayer","subTimeline","skippedPlayersMap","add","wrappedPlayer","TransitionAnimationPlayer","setRealPlayer","allQueriedPlayers","deleteOrUnsetInMap","playersByQueriedElement","classList","NG_ANIMATING_CLASSNAME","destroy","elementMatches","selector","Element","details0","_styleSummary","details1","timeline","TimelineBuilder","buildKeyframes","applyStylesToKeyframe","preStyleProps","postStyleProps","isEmpty","_allowEmptyAnimation","duration","ɵPRE_STYLE","_keyframes","keyframe","finalKeyframe","AUTO_STYLE","finalKeyframes","preProps","size","iteratorToArray","values","postProps","SubTimelineBuilder","containsAnimation","_stretchStartingKeyframe","limit","kf","timeAtKeyframe","oldOffset","roundOffset","totalTime","newKeyframes","Animation","buildTimelines","startingStyles","destinationStyles","locals","subInstructions","start","isArray","normalizeStyles","dest","ElementInstructionMap","Error","errorMessage","WebAnimationsStyleNormalizer","normalizeStyleValue","userProvidedProperty","normalizedProperty","errors","unit","strVal","toString","trim","DIMENSIONAL_PROP_MAP","valAndSuffixMatch","match","split","AnimationTransitionFactory","build","currentState","nextState","animationLocals","transitionLocals","ast","backupStateStyles","_stateStyles","currentStateStyles","nextStateStyles","buildAnimationTimelines","animation","join","preStyleMap","Map","postStyleMap","queriedElements","tl","elm","getOrSetAsInMap","AnimationTrigger","transitionFactories","states","obj","style","styleTuple","balanceProperties","matchTransition","TimelineAnimationEngine","create","instructions","_animations","autoStylesMap","EMPTY_INSTRUCTION_MAP","inst","computeStyle","optimizeGroupPlayer","players","_playersById","register","_getPlayer","pause","restart","StateValue","input","absorbValues","AnimationTransitionNamespace","_engine","_triggers","isTriggerEventValid","triggersWithStates","statesByElement","afterFlush","defaultToFallback","_getTrigger","NG_TRIGGER_CLASSNAME","fromState","toState","isObj","playersOnElement","queued","transition","isFallbackTransition","fallbackTransition","totalQueuedPlayers","_queue","remove","index","indexOf","splice","playersByElement","_destroyInnerNodes","context","animate","listToArray","querySelectorAll","NG_TRIGGER_SELECTOR","contains","_hostClassName","innerNs","namespacesByHostElement","removeNode","doNotRecurse","engine","LEAVE_CLASSNAME","childElementCount","triggerStates","players_1","VOID_VALUE","destroyInnerAnimations","_onElementDestroy","currentPlayers","containsPotentialParentTransition","_elementListeners","visitedTriggers_1","elementStates","DEFAULT_STATE_VALUE","queuedRemovals","insertNode","parent","drainQueuedTransitions","entry","destroyed","baseEvent","makeAnimationEvent","listenOnPlayer","markedForDestroy","sort","a","b","d0","d1","find","containsData","TransitionAnimationEngine","newlyInserted","newHostElements","_onRemovalComplete","onRemovalComplete","_balanceNamespaceList","ns","_namespaceList","found","nextNamespace","_fetchNamespace","containerElement","stateMap","flush","_flushFns","_whenQuietFns","quietFns_1","subTimelines","skippedPlayers","allPreStyleElements","allPostStyleElements","allEnterNodes","enterNodes","collectEnterElements","document","body","_buildInstruction","stretchStartingKeyframe","append","queuedInstructions","stringMap","props","setVal_1","setVal","allPreviousPlayersMap","sortedParentElements","unshift","_beforeAnimationBuild","leaveNodes","LEAVE_SELECTOR","cloakAndComputeStyles","subPlayers","innerPlayer","_buildAnimation","preStylesMap","parentHasPriority","parentPlayers","rootPlayers","fromStyles","setStyles","toStyles","playersForElement","elementPlayers","parentNode","playersForThisElement","elementContainsData","_getPreviousPlayers","queriedElementPlayers","isRemovalAnimation_1","targetNameSpaceId","isRemovalTransition","undefined","targetTriggerName","ENTER_SELECTOR","NG_ANIMATING_SELECTOR","TransitionAst","LEAVE_TOKEN_REGEX","RegExp","LEAVE_TOKEN","AnimationAstBuilderVisitor","visitTrigger","queryCount","depCount","transitions","definitions","def","type","stateDef_1","n","visitState","visitTransition","visitGroup","furthestTime","steps","step","innerAst","visitAnimationNode","visitAnimate","timingAst","constructTimingAst","timings","currentAnimateTimings","styleMetadata","visitKeyframes","styleMetadata_1","newStyleData","_makeStyleAst","collectedEasing","styleData","isObject","_validateStyleAst","endTime","startTime","updateCollectedStyle","collectedEntry","KeyframesAst","MAX_KEYFRAME_OFFSET","totalKeyframesWithOffsets","offsets","offsetsOutOfOrder","keyframesOutOfRange","previousOffset","style$$1","offsetVal","offset","consumeOffset","generatedOffset","animateDuration","visitQuery","parentSelector","currentQuery","normalizeSelector","includeSelf","currentQuerySelector","collectedStyles","visitStagger","resolveTiming","AnimationAstBuilderContext","currentTransition","ROOT_SELECTOR","existingInstructions","_map","AnimationTimelineContext","initialTimeline","parentContext","updateLocals","newLocals","skipIfExists","resolveTimingValue","_copyLocals","createSubContext","newTime","target","currentTimeline","fork","currentQueryIndex","appendInstructionToTimeline","AnimationTimelineBuilderVisitor","finalStyles","visit","visitAnimateChild","elementInstructions","consume","visitSequence","subContextCount","snapshotCurrentStyles","previousNode","DEFAULT_NOOP_PREVIOUS_NODE","innerTimelines","hasDelay","innerContext","delayNextStep","visitTiming","incrementTime","visitStyle","getCurrentStyleProperties","forwardFrame","innerTimeline","delayVal","StyleAst","elms","invokeQuery","originalSelector","multi","currentQueryTotal","sameElementTimeline","Math","max","abs","maxTime","staggerTransformer","_elementTimelineStylesLookup","_globalTimelineMap","_previousKeyframe","_currentKeyframe","existingBuilder","containsOnlyPendingStyles","_globalTimelineStyles","_loadKeyframe","flattenStyles","val","interpolateLocals","_backFill","_pendingStyles","_localTimelineStyles","getFinalKeyframe","properties","key1","key","currentValues","delete","cloakElement","display","filterNodeClasses","rootElements","cursor","nextCursor","querySelector","nextElementSibling","parentElement","driver","elements","elementPropsMap","defaultStyle","cloakVals","defaultValue","NoopAnimationDriver","createTransitionInstruction","createTimelineInstruction","optional","results","apply","allStyles","allProperties","token","makeBooleanMap","hasAmpersand","replace","parseFloat","visitor","node","visitReference","visitAnimateRef","parseTransitionExpr","transitionValue","expressions","parseInnerTransitionStr","eventStr","parseAnimationAlias","alias","makeLambdaFromStates","lhs","rhs","lhsMatch","ANY_STATE","normalizer","normalizedKeyframes","previousKeyframe","isSameOffset","normalizedKeyframe","normalizedProp","normalizedValue","normalizePropertyName","parseTimeExpression","exp","allowNegativeValues","regex","matches","_convertTimeValueToMS","delayMatch","floor","easingVal","containsErrors","startIndex","destination","readPrototype","normalizeAnimationEntry","matchAndValidate","prefixLength","suffixLength","str","matchAndReplace","iterator"],"mappings":"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"}