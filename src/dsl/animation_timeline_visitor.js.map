{"version":3,"sources":["../../../../../modules/@angular/animation/src/dsl/animation_timeline_visitor.ts"],"names":[],"mappings":"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","file":"animation_timeline_visitor.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimationPlayer, AnimationStyles} from '@angular/core';\n\nimport {StyleData} from '../common/style_data';\nimport {copyStyles, normalizeStyles, parseTimeExpression} from '../common/util';\n\nimport {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';\nimport * as meta from './animation_metadata';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\n/**\n * @param {?} ast\n * @param {?=} startingStyles\n * @param {?=} finalStyles\n * @return {?}\n */\nexport function buildAnimationKeyframes(\n    ast: meta.AnimationMetadata | meta.AnimationMetadata[], startingStyles: StyleData = {},\n    finalStyles: StyleData = {}): AnimationTimelineInstruction[] {\n  const /** @type {?} */ normalizedAst = Array.isArray(ast) ? meta.sequence( /** @type {?} */((<meta.AnimationMetadata[]>ast))) : /** @type {?} */((\n                                             <meta.AnimationMetadata>ast));\n  return new AnimationTimelineVisitor().buildKeyframes(normalizedAst, startingStyles, finalStyles);\n}\n\nexport declare type StyleAtTime = {\n  time: number; value: string | number;\n};\nexport class AnimationTimelineContext {\n  currentTimeline: TimelineBuilder;\n  currentAnimateTimings: meta.AnimateTimings;\n  previousNode: meta.AnimationMetadata = /** @type {?} */(( <meta.AnimationMetadata>{}));\n  subContextCount = 0;\n/**\n * @param {?} errors\n * @param {?} timelines\n * @param {?=} initialTimeline\n */\nconstructor(\npublic errors: any[],\npublic timelines: TimelineBuilder[],\n      initialTimeline: TimelineBuilder = null) {\n    this.currentTimeline = initialTimeline || new TimelineBuilder(0);\n    timelines.push(this.currentTimeline);\n  }\n/**\n * @param {?=} inherit\n * @return {?}\n */\ncreateSubContext(inherit: boolean = false): AnimationTimelineContext {\n    const /** @type {?} */ context = new AnimationTimelineContext(\n        this.errors, this.timelines, this.currentTimeline.fork(inherit));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n    this.subContextCount++;\n    return context;\n  }\n/**\n * @param {?=} newTime\n * @return {?}\n */\ntransformIntoNewTimeline(newTime = 0) {\n    const /** @type {?} */ oldTimeline = this.currentTimeline;\n    const /** @type {?} */ oldTime = oldTimeline.time;\n    if (newTime > 0) {\n      oldTimeline.time = newTime;\n    }\n    this.currentTimeline = oldTimeline.fork(true);\n    oldTimeline.time = oldTime;\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nincrementTime(time: number) {\n    this.currentTimeline.forwardTime(this.currentTimeline.time + time);\n  }\n}\n\nfunction AnimationTimelineContext_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationTimelineContext.prototype.currentTimeline;\n/** @type {?} */\nAnimationTimelineContext.prototype.currentAnimateTimings;\n/** @type {?} */\nAnimationTimelineContext.prototype.previousNode;\n/** @type {?} */\nAnimationTimelineContext.prototype.subContextCount;\n/** @type {?} */\nAnimationTimelineContext.prototype.errors;\n/** @type {?} */\nAnimationTimelineContext.prototype.timelines;\n}\n\nexport class AnimationTimelineVisitor implements AnimationDslVisitor {\n/**\n * @param {?} ast\n * @param {?} startingStyles\n * @param {?} finalStyles\n * @return {?}\n */\nbuildKeyframes(ast: meta.AnimationMetadata, startingStyles: StyleData, finalStyles: StyleData):\n      AnimationTimelineInstruction[] {\n    const /** @type {?} */ context = new AnimationTimelineContext([], []);\n    context.currentTimeline.setStyles(startingStyles);\n\n    visitAnimationNode(this, ast, context);\n    const /** @type {?} */ normalizedFinalStyles = copyStyles(finalStyles, true);\n\n    // this is a special case for when animate(TIME) is used (without any styles)\n    // thus indicating to create an animation arc between the final keyframe and\n    // the destination styles. When this occurs we need to ensure that the styles\n    // that are missing on the finalStyles map are set to AUTO\n    if (Object.keys(context.currentTimeline.getFinalKeyframe()).length == 0) {\n      context.currentTimeline.properties.forEach(prop => {\n        const /** @type {?} */ val = normalizedFinalStyles[prop];\n        if (val == null) {\n          normalizedFinalStyles[prop] = meta.AUTO_STYLE;\n        }\n      });\n    }\n\n    context.currentTimeline.setStyles(normalizedFinalStyles);\n    const /** @type {?} */ timelineInstructions: AnimationTimelineInstruction[] = [];\n    context.timelines.forEach(timeline => {\n      // this checks to see if an actual animation happened\n      if (timeline.hasStyling()) {\n        timelineInstructions.push(timeline.buildKeyframes());\n      }\n    });\n\n    if (timelineInstructions.length == 0) {\n      timelineInstructions.push(createTimelineInstruction([], 0, 0, ''));\n    }\n    return timelineInstructions;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitState(ast: meta.AnimationStateMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitTransition(ast: meta.AnimationTransitionMetadata, context: any): any {\n    // these values are not visited in this AST\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSequence(ast: meta.AnimationSequenceMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ subContextCount = context.subContextCount;\n    if (context.previousNode.type == meta.AnimationMetadataType.Style) {\n      context.currentTimeline.forwardFrame();\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n    ast.steps.map(s => visitAnimationNode(this, s, context));\n    context.previousNode = ast;\n    if (context.subContextCount > subContextCount) {\n      context.transformIntoNewTimeline();\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitGroup(ast: meta.AnimationGroupMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ innerTimelines: TimelineBuilder[] = [];\n    let /** @type {?} */ furthestTime = context.currentTimeline.currentTime;\n    ast.steps.map(s => {\n      const /** @type {?} */ innerContext = context.createSubContext(false);\n      innerContext.currentTimeline.snapshotCurrentStyles();\n      visitAnimationNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    context.transformIntoNewTimeline(furthestTime);\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.currentTimeline.snapshotCurrentStyles();\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitAnimate(ast: meta.AnimationAnimateMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ timings = ast.timings.hasOwnProperty('duration') ? /** @type {?} */((\n        <meta.AnimateTimings>ast.timings)) :\n        parseTimeExpression( /** @type {?} */((<string|number>ast.timings)), context.errors);\n    context.currentAnimateTimings = timings;\n\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    const /** @type {?} */ astType = ast.styles ? ast.styles.type : -1;\n    if (astType == meta.AnimationMetadataType.KeyframeSequence) {\n      this.visitKeyframeSequence( /** @type {?} */((<meta.AnimationKeyframesSequenceMetadata>ast.styles)), context);\n    } else {\n      context.incrementTime(timings.duration);\n      if (astType == meta.AnimationMetadataType.Style) {\n        this.visitStyle( /** @type {?} */((<meta.AnimationStyleMetadata>ast.styles)), context);\n      }\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitStyle(ast: meta.AnimationStyleMetadata, context: AnimationTimelineContext) {\n    // this is a special case when a style() call is issued directly after\n    // a call to animate(). If the clock is not forwarded by one frame then\n    // the style() calls will be merged into the previous animate() call\n    // which is incorrect.\n    if (!context.currentAnimateTimings &&\n        context.previousNode.type == meta.AnimationMetadataType.Animate) {\n      context.currentTimeline.forwardFrame();\n    }\n\n    const /** @type {?} */ normalizedStyles = normalizeStyles(new AnimationStyles(ast.styles));\n    const /** @type {?} */ easing = context.currentAnimateTimings && context.currentAnimateTimings.easing;\n    if (easing) {\n      normalizedStyles['easing'] = easing;\n    }\n\n    context.currentTimeline.setStyles(normalizedStyles);\n    context.previousNode = ast;\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyframeSequence(\n      ast: meta.AnimationKeyframesSequenceMetadata, context: AnimationTimelineContext) {\n    const /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;\n    const /** @type {?} */ limit = ast.steps.length - 1;\n    const /** @type {?} */ firstKeyframe = ast.steps[0];\n\n    let /** @type {?} */ offsetGap = 0;\n    const /** @type {?} */ containsOffsets = firstKeyframe.styles.find(styles => styles['offset'] >= 0);\n    if (!containsOffsets) {\n      offsetGap = MAX_KEYFRAME_OFFSET / limit;\n    }\n\n    const /** @type {?} */ keyframeDuration = context.currentAnimateTimings.duration;\n    const /** @type {?} */ innerContext = context.createSubContext(true);\n    const /** @type {?} */ innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = context.currentAnimateTimings.easing;\n\n    // this will ensure that all collected styles so far\n    // are populated into the first keyframe of the keyframes()\n    // timeline (even if there exists a starting keyframe then\n    // it will override the contents of the first frame later)\n    innerTimeline.snapshotCurrentStyles();\n\n    ast.steps.map((step: meta.AnimationStyleMetadata, i: number) => {\n      const /** @type {?} */ normalizedStyles = normalizeStyles(new AnimationStyles(step.styles));\n      const /** @type {?} */ offset = containsOffsets ? /** @type {?} */(( <number>normalizedStyles['offset'])) :\n                                       (i == limit ? MAX_KEYFRAME_OFFSET : i * offsetGap);\n      innerTimeline.forwardTime(offset * keyframeDuration);\n      innerTimeline.setStyles(normalizedStyles);\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child even if the new timeline below is not used\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.transformIntoNewTimeline(context.currentTimeline.time + keyframeDuration);\n    context.currentTimeline.snapshotCurrentStyles();\n    context.previousNode = ast;\n  }\n}\nexport class TimelineBuilder {\npublic time: number = 0;\npublic easing: string = '';\nprivate _currentKeyframe: StyleData;\nprivate _keyframes = new Map<number, StyleData>();\nprivate _styleSummary: {[prop: string]: StyleAtTime} = {};\nprivate _localTimelineStyles: StyleData;\nprivate _backFill: StyleData = {};\n/**\n * @param {?} startTime\n * @param {?=} _globalTimelineStyles\n * @param {?=} inheritedBackFill\n * @param {?=} inheritedStyles\n */\nconstructor(\npublic startTime: number,\nprivate _globalTimelineStyles: StyleData = null,\n      inheritedBackFill: StyleData = null, inheritedStyles: StyleData = null) {\n    if (inheritedBackFill) {\n      this._backFill = inheritedBackFill;\n    }\n\n    this._localTimelineStyles = Object.create(this._backFill, {});\n    if (inheritedStyles) {\n      this._localTimelineStyles = copyStyles(inheritedStyles, false, this._localTimelineStyles);\n    }\n\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n    }\n    this._loadKeyframe();\n  }\n/**\n * @return {?}\n */\nhasStyling(): boolean { return this._keyframes.size > 1; }\n/**\n * @return {?}\n */\nget currentTime() { return this.startTime + this.time; }\n/**\n * @param {?=} inherit\n * @return {?}\n */\nfork(inherit: boolean = false): TimelineBuilder {\n    let /** @type {?} */ inheritedBackFill = inherit ? this._backFill : null;\n    let /** @type {?} */ inheritedStyles = inherit ? this._localTimelineStyles : null;\n    return new TimelineBuilder(\n        this.currentTime, this._globalTimelineStyles, inheritedBackFill, inheritedStyles);\n  }\n/**\n * @return {?}\n */\nprivate _loadKeyframe() {\n    this._currentKeyframe = this._keyframes.get(this.time);\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = Object.create(this._backFill, {});\n      this._keyframes.set(this.time, this._currentKeyframe);\n    }\n  }\n/**\n * @return {?}\n */\nforwardFrame() {\n    this.time++;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} time\n * @return {?}\n */\nforwardTime(time: number) {\n    this.time = time;\n    this._loadKeyframe();\n  }\n/**\n * @param {?} prop\n * @param {?} value\n * @return {?}\n */\nprivate _updateStyle(prop: string, value: string|number) {\n    if (prop != 'easing') {\n      if (!this._localTimelineStyles[prop]) {\n        this._backFill[prop] = this._globalTimelineStyles[prop] || meta.AUTO_STYLE;\n      }\n      this._localTimelineStyles[prop] = value;\n      this._globalTimelineStyles[prop] = value;\n      this._styleSummary[prop] = {time: this.currentTime, value};\n    }\n  }\n/**\n * @param {?} styles\n * @return {?}\n */\nsetStyles(styles: StyleData) {\n    Object.keys(styles).forEach(prop => {\n      if (prop !== 'offset') {\n        const /** @type {?} */ val = styles[prop];\n        this._currentKeyframe[prop] = val;\n        this._updateStyle(prop, val);\n      }\n    });\n    Object.keys(this._localTimelineStyles).forEach(prop => {\n      if (!this._currentKeyframe.hasOwnProperty(prop)) {\n        this._currentKeyframe[prop] = this._localTimelineStyles[prop];\n      }\n    });\n  }\n/**\n * @return {?}\n */\nsnapshotCurrentStyles() { copyStyles(this._localTimelineStyles, false, this._currentKeyframe); }\n/**\n * @return {?}\n */\ngetFinalKeyframe() { return this._keyframes.get(this.time); }\n/**\n * @return {?}\n */\nget properties() {\n    const /** @type {?} */ properties: string[] = [];\n    for (let /** @type {?} */ prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n/**\n * @param {?} timeline\n * @return {?}\n */\nmergeTimelineCollectedStyles(timeline: TimelineBuilder) {\n    Object.keys(timeline._styleSummary).forEach(prop => {\n      const /** @type {?} */ details0 = this._styleSummary[prop];\n      const /** @type {?} */ details1 = timeline._styleSummary[prop];\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nbuildKeyframes(): AnimationTimelineInstruction {\n    const /** @type {?} */ finalKeyframes: StyleData[] = [];\n    // special case for when there are only start/destination\n    // styles but no actual animation animate steps...\n    if (this.time == 0) {\n      const /** @type {?} */ targetKeyframe = this.getFinalKeyframe();\n\n      const /** @type {?} */ firstKeyframe = copyStyles(targetKeyframe, true);\n      firstKeyframe['offset'] = 0;\n      finalKeyframes.push(firstKeyframe);\n\n      const /** @type {?} */ lastKeyframe = copyStyles(targetKeyframe, true);\n      lastKeyframe['offset'] = 1;\n      finalKeyframes.push(lastKeyframe);\n    } else {\n      this._keyframes.forEach((keyframe, time) => {\n        const /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);\n        finalKeyframe['offset'] = time / this.time;\n        finalKeyframes.push(finalKeyframe);\n      });\n    }\n\n    return createTimelineInstruction(finalKeyframes, this.time, this.startTime, this.easing);\n  }\n}\n\nfunction TimelineBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nTimelineBuilder.prototype.time;\n/** @type {?} */\nTimelineBuilder.prototype.easing;\n/** @type {?} */\nTimelineBuilder.prototype._currentKeyframe;\n/** @type {?} */\nTimelineBuilder.prototype._keyframes;\n/** @type {?} */\nTimelineBuilder.prototype._styleSummary;\n/** @type {?} */\nTimelineBuilder.prototype._localTimelineStyles;\n/** @type {?} */\nTimelineBuilder.prototype._backFill;\n/** @type {?} */\nTimelineBuilder.prototype.startTime;\n/** @type {?} */\nTimelineBuilder.prototype._globalTimelineStyles;\n}\n\n"]}